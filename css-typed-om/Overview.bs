<pre class='metadata'>
Title:  CSS Typed OM Level 1
Status: ED
Group: houdini
ED: https://drafts.css-houdini.org/css-typed-om-1/
Previous Version: https://www.w3.org/TR/2016/WD-css-typed-om-1-20160607/
Shortname: css-typed-om
Level: 1
Abstract: Converting CSSOM value strings into meaningfully typed JavaScript representations and back can incur a significant performance overhead. This specification exposes CSS values as typed JavaScript objects to facilitate their performant manipulation.
Editor: Shane Stephens, shanestephens@google.com
Editor: Tab Atkins-Bittner, Google, http://xanthir.com/contact/, w3cid 42199
Repository: w3c/css-houdini-drafts
Ignored Vars: type, unit
Ignored Terms: Drawable, paint image definition, list-valued property, list-valued property iteration, parse a CSSStyleValue
Markup Shorthands: markdown yes
</pre>

<style>
/* Put nice boxes around each algorithm. */
[data-algorithm]:not(.heading) {
  padding: .5em;
  border: thin solid #ddd; border-radius: .5em;
  margin: .5em calc(-0.5em - 1px);
}
[data-algorithm]:not(.heading) > :first-child {
  margin-top: 0;
}
[data-algorithm]:not(.heading) > :last-child {
  margin-bottom: 0;
}
</style>

<pre class=anchors>
urlPrefix: http://www.ecma-international.org/ecma-262/6.0/#sec-; type: dfn; spec: ecma-262
	text: RangeError; url: native-error-types-used-in-this-standard-rangeerror
</pre>

<pre class=link-defaults>
spec:dom; type:interface;
	text:Document
	text:Element;
spec:css-color-3; type:property; text:color;
spec:css-speech-1; type:property;
	text:cue-after;
	text:cue-before;
	text:pause-after;
	text:pause-before;
	text:speak;
	text:voice-family;
spec:css21; type:property;
	text:max-height;
	text:max-width;
	text:min-height;
	text:min-width;
spec:css-tables-3; type:property;
	text:border-collapse;
	text:caption-side;
	text:empty-cells;
	text:table-layout;
spec:css-position-3; type:value; for:left; text:auto;
spec:css-transforms-1;
	type:type;
		text:<transform-list>;
		text:<transform-function>;
	type:property;
		text:transform;
		text:backface-visibility;
		text:perspective;
		text:perspective-origin;
		text:transform-origin;
		text:transform-style;
spec:css-syntax-3;
	type:dfn; text:identifier
spec:infra;
	type: dfn; text: list
</pre>

Introduction {#intro}
=====================

Converting CSSOM value strings into meaningfully typed JavaScript representations and
back can incur a significant performance overhead. This specification exposes CSS values
as typed JavaScript objects to facilitate their performant manipulation.

The API exposed by this specification is designed for performance rather than ergonomics.
Some particular considerations:
*   retrieved JavaScript representations of CSS values are not mutable - instead updates
		must explicitly be set using the API.
*   objects are organized for consistency rather than ease of access. For example, even
		though lengths are often numeric pixel values, a declared {{CSSNumericValue}} can't be
		treated as a number without first explicitly casting it to a {{CSSUnitValue}}, as calc
		expressions and keywords are also valid lengths.

<!--
 ██████   ██████   ██████   ██████  ████████ ██    ██ ██       ████████ ██     ██    ███    ██       ██     ██ ████████
██    ██ ██    ██ ██    ██ ██    ██    ██     ██  ██  ██       ██       ██     ██   ██ ██   ██       ██     ██ ██
██       ██       ██       ██          ██      ████   ██       ██       ██     ██  ██   ██  ██       ██     ██ ██
██        ██████   ██████   ██████     ██       ██    ██       ██████   ██     ██ ██     ██ ██       ██     ██ ██████
██             ██       ██       ██    ██       ██    ██       ██        ██   ██  █████████ ██       ██     ██ ██
██    ██ ██    ██ ██    ██ ██    ██    ██       ██    ██       ██         ██ ██   ██     ██ ██       ██     ██ ██
 ██████   ██████   ██████   ██████     ██       ██    ████████ ████████    ███    ██     ██ ████████  ███████  ████████
-->

{{CSSStyleValue}} objects {#stylevalue-objects}
============================================

<pre class='idl'>
interface CSSStyleValue {
	readonly attribute DOMString cssText;
	static (CSSStyleValue or sequence&lt;CSSStyleValue>)? parse(DOMString property, DOMString cssText);
};
</pre>

{{CSSStyleValue}} objects are the base class of all CSS Values accessible via the Typed OM API.
Values that can't yet be directly supported by a {{CSSStyleValue}} subclass
are also represented as {{CSSStyleValue}} objects.

The <dfn attribute for=CSSStyleValue>cssText</dfn> attribute,
on getting,
returns a normalized representation
(see [[#stylevalue-normalization]])
of the value the {{CSSStyleValue}} object represents.

<div algorithm="parse a CSSStyleValue">
	The <dfn method for=CSSStyleValue>parse(DOMString <var>property</var>, DOMString <var>cssText</var>)</dfn>,
	when invoked,
	must run these steps:

	1. Attempt to parse |property| as an <<ident>>.
		If this fails,
		[=throw=] a {{SyntaxError}} and exit this algorithm.
		Otherwise, let |property| be the parsed result.
		If |property| does not start with two dashes (U+002D HYPHEN),
		let |property| be |property| [=ASCII lowercased=].

	2. If |property| is not a [=supported property name=],
		[=throw=] a {{TypeError}} and exit this algorithm.

	3. Attempt to <a lt="parse something according to a CSS grammar">parse</a> |cssText| according to |property|’s grammar.
		If this fails,
		[=throw=] a {{SyntaxError}} and exit this algorithm.
		Otherwise,
		let |value| be the parsed result.

	4. If |property| is a [=list-valued property=],
		subdivide |value| into a list of {{CSSStyleValue}} objects,
		each representing one [=list-valued property iteration=],
		and let |value| be the result.

	5. Return a {{CSSStyleValue}} representing |value|.
</div>

<!--
 ██████  ████████ ██    ██ ██       ████████ ██     ██    ███    ████████
██    ██    ██     ██  ██  ██       ██       ███   ███   ██ ██   ██     ██
██          ██      ████   ██       ██       ████ ████  ██   ██  ██     ██
 ██████     ██       ██    ██       ██████   ██ ███ ██ ██     ██ ████████
      ██    ██       ██    ██       ██       ██     ██ █████████ ██
██    ██    ██       ██    ██       ██       ██     ██ ██     ██ ██
 ██████     ██       ██    ████████ ████████ ██     ██ ██     ██ ██
-->

The {{StylePropertyMap}} {#the-stylepropertymap}
================================================

<pre class='idl'>
interface StylePropertyMapReadOnly {
	CSSStyleValue? get(DOMString property);
	sequence&lt;CSSStyleValue> getAll(DOMString property);
	boolean has(DOMString property);
	iterable&lt;DOMString, (CSSStyleValue or sequence&lt;CSSStyleValue>)>;
	sequence&lt;DOMString> getProperties();
	stringifier;
};

callback UpdateFunction = CSSStyleValue (CSSStyleValue oldValue);

interface StylePropertyMap : StylePropertyMapReadOnly {
	void append(DOMString property, (CSSStyleValue or DOMString)... values);
	void delete(DOMString property);
	void set(DOMString property, (CSSStyleValue or DOMString)... values);
        void update(DOMString property, UpdateFunction updateFunction);
};
</pre>

A {{StylePropertyMapReadOnly}} object has an associated <dfn>property model</dfn>,
which is a list of property - sequence&lt;{{CSSStyleValue}}> pairs. This list
is initialized differently depending on where the {{CSSStyleValue}} is used
(see
[[#computed-stylepropertymapreadonly-objects]],
[[#declared-stylepropertymap-objects]], and
[[#inline-stylepropertymap-objects]]).

<div class='note'>
The sequence of {{CSSStyleValue}}s associated with a property do
not represent multiple successive definitions of that property's value.
Instead, sequences represent values associated with list-valued properties.

This approach allows single-valued properties to become list-valued in the
future without breaking code that relies on calling
{{StylePropertyMapReadOnly/get()}} and/or
{{StylePropertyMap/set()}} for those properties.
</div>

<div algorithm="append to a StylePropertyMap">
	The <dfn method for=StylePropertyMap>append(DOMString <var>property</var> (CSSStyleValue or DOMString)... <var>values</var>)</dfn> method,
	when invoked,
	must run these steps:

	1. If |property| does not start with two dashes (U+002D HYPHEN),
		let |property| be |property| [=ASCII lowercased=].

	2. If |property| is not a [=supported property name=],
		[=throw=] a {{TypeError}} and exit this algorithm.

	3. If |property| is not a [=list-valued property=],
		[=throw=] a {{TypeError}} and exit this algorithm.

	4. If {{StylePropertyMap}}’s [=property model=] contains an entry for |property|,
		let |entry| be that entry.
		Otherwise, create a new entry for |property| with an empty list,
		add it to the [=property model=],
		and let |entry| be the newly-created entry.

	5. Let |values to append| be the empty list.

	6. For each |value| in |values|:
		: If |value| is a {{CSSStyleValue}},
		:: If |value| does not match the grammar of a [=list-valued property iteration=] of |property|,
			[=throw=] a {{TypeError}} and exit this algorithm.
			Otherwise, append |value| to the end of |values to append|.
		: If |value| is a {{DOMString}},
		::	[=Parse a CSSStyleValue=] with property |property| and value |value|.
			If the result is null,
			[=throw=] a {{TypeError}} and exit this algorithm.
			Otherwise, append each [=list-valued property iteration=] in the result to the end of |values to append|.

	7. Append |values to append| to the end of |entry|’s list.
</div>

<div algorithm>
    To <dfn>get a value from a StylePropertyMap</dfn>, run these steps:

    Issue: write this.
</div>

<div algorithm>
    To <dfn>set a value on a StylePropertyMap</dfn>, run these steps:

    Issue: write this.
</div>

The <dfn method for=StylePropertyMap>update(DOMString <var>property</var>,
UpdateFunction <var>updateFunction</var>)</dfn> method, when invoked, must
[=update a value in a StylePropertyMap=] with property name
<var>property</var>, update function <var>updateFunction</var>, and property
map set to the object this method was invoked on .

<div algorith>
    To <dfn>update a value in a StylePropertyMap</dfn> given a <var>property
    name</var>, <var>update function</var>, and <var>property map</var>, run these
    steps:

    1.  Let <var>old value</var> be the result of running the algorithm to
        [=get a value from a StylePropertyMap=] with property name <var>property
        name</var> and property map <var>property map</var>.

    2.  Let <var>new value</var> be the return value given by [=invoking=] the callback
        <var>update function</var> with a single input of <var>old value</var>.

    3.  Run the algorithm to [=set a value on a StylePropertyMap=] with property name <var>property name</var>,
        value <var>new value</var>, and property map <var>property map</var>.

</div>

The <dfn method for=StylePropertyMap>getProperties()</dfn> method returns all of the properties listed in
the [=property model=]. This list of properties is sorted in the following manner:

*   normal properties are sorted alphabetically.
*   custom properties are sorted by increasing code point order.
*   custom properties are sorted after normal properties.

Issue(145): should refactor out value type-checking, as it'll be needed by the rest of the setters too

Issue(147): need a robust description of what "a type that <var ignore>property</var> can't accept" means.

Issue(148): add detailed descriptions of the rest of the methods on {{StylePropertyMap}}

Issue(149): describe that these are not live objects

Computed {{StylePropertyMapReadOnly}} objects {#computed-stylepropertymapreadonly-objects}
--------------------------------------------------------------------------

<pre class='idl'>
partial interface Window {
	StylePropertyMapReadOnly getComputedStyleMap(Element element, optional DOMString? pseudoElt);
};
</pre>

<dfn>Computed StylePropertyMap</dfn> objects represent the computed style of an
{{Element}} or pseudo element, and are accessed by calling the
{{Window/getComputedStyleMap()}} method.

When constructed, the [=property model=] for [=computed StylePropertyMap=]
objects is initialized to contain an entry for every valid CSS property supported by the User Agent.

Note: The StylePropertyMap returned by getComputedStyleMap represents computed style,
			not resolved style. In this regard it provides different values than those
			in objects returned by getComputedStyle.

Declared {{StylePropertyMap}} objects {#declared-stylepropertymap-objects}
----------------------------------------------------------------------------

<pre class='idl'>
partial interface CSSStyleRule {
	[SameObject] readonly attribute StylePropertyMap styleMap;
};
</pre>

<dfn>Declared StylePropertyMap</dfn> objects represent style property-value pairs embedded
in a style rule, and are accessed via the <dfn attribute for=CSSStyleRule>styleMap</dfn>
attribute of {{CSSStyleRule}} objects.

When constructed, the [=property model=] for [=declared StylePropertyMap=]
objects is initialized to contain
an entry for each property that is paired with at least one valid value inside the
{{CSSStyleRule}} that the object represents. The value for a given property is
the last valid value provided by the {{CSSStyleRule}} object.


Inline {{StylePropertyMap}} objects {#inline-stylepropertymap-objects}
----------------------------------------------------------------------

<pre class='idl'>
partial interface Element {
	[SameObject] readonly attribute StylePropertyMap styleMap;
};
</pre>

<dfn>Inline StylePropertyMap</dfn> objects represent inline style declarations attached
directly to {{Element}}s. They are accessed via the <dfn attribute for=Element>styleMap</dfn>
attribute of {{Element}} objects.

When constructed, the [=property model=] for [=inline StylePropertyMap=] objects
is initialized to contain an
entry for each property that is paired with at least one valid value in the string
representing the style attribute for the Element that the object is associated with.
The value for a given property is the last valid value provided in the string.

{{CSSStyleValue}} subclasses {#stylevalue-subclasses}
==================================================

<!--
██     ██ ██    ██ ████████     ███    ████████   ██████  ████████ ████████
██     ██ ███   ██ ██     ██   ██ ██   ██     ██ ██    ██ ██       ██     ██
██     ██ ████  ██ ██     ██  ██   ██  ██     ██ ██       ██       ██     ██
██     ██ ██ ██ ██ ████████  ██     ██ ████████   ██████  ██████   ██     ██
██     ██ ██  ████ ██        █████████ ██   ██         ██ ██       ██     ██
██     ██ ██   ███ ██        ██     ██ ██    ██  ██    ██ ██       ██     ██
 ███████  ██    ██ ██        ██     ██ ██     ██  ██████  ████████ ████████
-->

{{CSSUnparsedValue}} objects {#unparsedvalue-objects}
----------------------------------------------

<pre class='idl'>
interface CSSUnparsedValue : CSSStyleValue {
	iterable<(DOMString or CSSVariableReferenceValue)>;
};

interface CSSVariableReferenceValue {
	attribute DOMString variable;
	attribute CSSUnparsedValue? fallback;
};
</pre>

{{CSSUnparsedValue}} objects represent values that reference custom properties.
They represent a list of string fragments and variable references.

They have a <dfn attribute for=CSSUnparsedValue>\[[tokens]]</dfn> internal slot,
which is a [=list=] of alternating {{DOMString}} and {{CSSVariableReferenceValue}} objects.
This list is the object's [=values to iterate over=].


<!--
██    ██ ████████ ██    ██ ██      ██  ███████  ████████  ████████
██   ██  ██        ██  ██  ██  ██  ██ ██     ██ ██     ██ ██     ██
██  ██   ██         ████   ██  ██  ██ ██     ██ ██     ██ ██     ██
█████    ██████      ██    ██  ██  ██ ██     ██ ████████  ██     ██
██  ██   ██          ██    ██  ██  ██ ██     ██ ██   ██   ██     ██
██   ██  ██          ██    ██  ██  ██ ██     ██ ██    ██  ██     ██
██    ██ ████████    ██     ███  ███   ███████  ██     ██ ████████
-->

{{CSSKeywordValue}} objects {#keywordvalue-objects}
---------------------------------------------------

{{CSSKeywordValue}} objects represent CSS keywords and other [=identifiers=].

<pre class='idl'>
[Constructor(DOMString value)]
interface CSSKeywordValue : CSSStyleValue {
	attribute DOMString value;
};
</pre>

<div algorithm>
	The <dfn constructor for=CSSKeywordValue>CSSKeywordValue(|value|)</dfn> constructor must,
	when called,
	perform the following steps:

	1. [=Parse a component value=] from |value|,
		and let |keyword| be the result.

	2. If |keyword| is a syntax error,
		[=throw=] a {{SyntaxError}}.

	3. If |keyword| is anything but an [=identifier=],
		[=throw=] a {{SyntaxError}}.

	4. Otherwise, return a new {{CSSKeywordValue}}
		with its {{CSSKeywordValue/value}} internal slot
		set to the serialization of |keyword|.
</div>

<div class=issue>
	It's intentional that this does a CSS parse,
	rather than just taking the string literally.

	Goals are (1) allow .value to round-trip thru the constructor,
	and (2) allow .value to work when stitched directly into a string
	that's then fed to CSS.
	#2 requires us to have .value contain the appropriate CSS escapes,
	and #1 then requires us to parse those escapes.

	On the other hand,
	I think this conflicts with the most desirable handling of CSS strings;
	a CSSStringValue should take the value literally, I think.
	(Otherwise we have to do some weird things around quotes, I think.)
	Need to evaluate this holistically.

	Possible solution: different behavior between .value
	and the stringifier.
</div>

<div algorithm for="CSSKeywordValue.value">
	The <dfn attribute for=CSSKeywordValue>value</dfn> attribute of a {{CSSKeywordValue}} |this| must,
	on setting a value |value|,
	perform the following steps:

	1. [=Parse a component value=] from |value|,
		and let |keyword| be the result.

	2. If |keyword| is a syntax error,
		[=throw=] a {{SyntaxError}}.

	3. If |keyword| is anything but an [=identifier=],
		[=throw=] a {{SyntaxError}}.

	4. Otherwise, set |this|’s internal {{CSSKeywordValue/value}} slot
		to the serialization of |keyword|.

	On reading, {{CSSKeywordValue/value}}
	must return the serialization of |this|’s internal {{CSSKeywordValue/value}} slot.
</div>


<!--
██    ██ ██     ██ ██     ██ ████████ ████████  ████  ██████
███   ██ ██     ██ ███   ███ ██       ██     ██  ██  ██    ██
████  ██ ██     ██ ████ ████ ██       ██     ██  ██  ██
██ ██ ██ ██     ██ ██ ███ ██ ██████   ████████   ██  ██
██  ████ ██     ██ ██     ██ ██       ██   ██    ██  ██
██   ███ ██     ██ ██     ██ ██       ██    ██   ██  ██    ██
██    ██  ███████  ██     ██ ████████ ██     ██ ████  ██████
-->


Numeric Values: {#numeric-objects}
----------------------------------

{{CSSNumericValue}} objects represent CSS values that are numeric in nature
(<<number>>s, <<percentage>>s, <<dimension>>s).

* {{CSSUnitValue}} objects represent values that contain a single unit type
	(for example "42px").
* {{CSSCalcValue}} objects represent values that contain multiple units
	(for example "calc(56em + 10%)").

{{CSSNumericValue}} objects are not range-restricted.
Any valid numeric value can be represented by a {{CSSNumericValue}},
and that value will not be clamped, rounded, or rejected
when set on a [=declared StylePropertyMap=] or [=inline StylePropertyMap=].
Instead, clamping and/or rounding will occur during computation of style.

<div class='example'>
	The following code is valid

	<pre class=lang-js>
		myElement.styleMap.set("opacity", CSS.number(3));
		myElement.styleMap.set("z-index", CSS.number(15.4));

		console.log(myElement.styleMap.get("opacity").value); // 3
		console.log(myElement.styleMap.get("z-index").value); // 15.4

		var computedStyle = getComputedStyleMap(myElement);
		var opacity = computedStyle.get("opacity");
		var zIndex = computedStyle.get("z-index");
	</pre>

	After execution, the value of `opacity` is `1` ('opacity' is range-restricted),
	and the value of `zIndex` is `15` ('z-index' is rounded to an integer value).
</div>

Note that "numeric values" which incorporate variable references
will instead be represented as {{CSSUnparsedValue}} objects,
and keywords as {{CSSKeywordValue}} objects.


### Common Numeric Operations, and the {{CSSNumericValue}} Superclass ### {#numeric-value}

All numeric CSS values
(<<number>>s, <<percentage>>s, and <<dimension>>s)
are represented by subclasses of the {{CSSNumericValue}} interface.

<xmp class=idl>
	interface CSSNumericValue : CSSStyleValue {
		CSSNumericValue add(CSSNumericValue value);
		CSSNumericValue sub(CSSNumericValue value);
		CSSNumericValue mul(double value);
		CSSNumericValue div(double value);

		static CSSNumericValue from(DOMString cssText);
		CSSNumericValue to(DOMString unit);
	};
</xmp>

The methods on the {{CSSNumericValue}} superclass
represent operations that all numeric values can perform.

The following are the arithmetic operations you can perform on dimensions:

<div algorithm="CSSNumericValue.add()">
	The <dfn for=CSSNumericValue method>add(|value|)</dfn> method,
	when called on a {{CSSNumericValue}} |this|,
	must perform the following steps:

	1. If |this| and |value| are both [=strongly typed=],
		but to different types,
		[=throw=] a {{TypeError}}.

	2. If |this| and |value| are both {{CSSUnitValue}}s:
		and have the same {{CSSUnitValue/unit}},
		return a new {{CSSUnitValue}}
		with the same unit
		and a value equal to the sum of |this|’s and |value|’s values.

	3. Otherwise,
		return a {{CSSCalcValue}}
		representing the sum of the |this| and |value|.
</div>

<div algorithm="CSSNumericValue.sub()">
	The <dfn for=CSSNumericValue method>sub(|value|)</dfn> method,
	when called on a {{CSSNumericValue}} |this|,
	must perform the following steps:

	1. If |this| and |value| are both [=strongly typed=],
		but to different types,
		[=throw=] a {{TypeError}}.

	2. If |this| and |value| are both {{CSSUnitValue}}s:
		and have the same {{CSSUnitValue/unit}},
		return a new {{CSSUnitValue}}
		with the same unit
		and a value equal to the difference of |this|’s and |value|’s values.

	3. Otherwise,
		return a {{CSSCalcValue}}
		representing the difference of the |this| and |value|.
</div>

<div algorithm="CSSNumericValue.mul()">
	The <dfn for=CSSNumericValue method>mul(|value|)</dfn> method,
	when called on a {{CSSNumericValue}} |this|,
	must perform the following steps:

	1. If |this| is a {{CSSUnitValue}},
		return a new {{CSSUnitValue}}
		with the same unit
		and a value equal to |this|’s value times |value|.

	2. Otherwise,
		return a new {{CSSCalcValue}}
		containing the same keys,
		but with each value multiplied by |value|.
</div>

<div algorithm="CSSNumericValue.div()">
	The <dfn for=CSSNumericValue method>div(|value|)</dfn> method,
	when called on a {{CSSNumericValue}} |this|,
	must perform the following steps:

	1. If |this| is a {{CSSUnitValue}},
		return a new {{CSSUnitValue}}
		with the same unit
		and a value equal to |this|’s value divided by |value|.

	2. Otherwise,
		return a new {{CSSCalcValue}}
		containing the same keys,
		but with each value divided by |value|.
</div>

The following two factory methods allow a {{CSSNumericValue}} to be constructed directly.
Note that they are static methods,
existing directly on the {{CSSNumericValue}} interface object,
rather than on {{CSSNumericValue}} instances.

<div algorithm="CSSNumericValue.from(cssText)">
	The <dfn method for=CSSNumericValue>from(|cssText|)</dfn> method,
	when called,
	must perform the following steps:

	1. [=Parse a component value=] from |cssText|
		and let |result| be the result.
		If |result| is a syntax error,
		[=throw=] a {{SyntaxError}}
		and abort this algorithm.

	2. If |result| is not a <<number-token>>, <<percentage-token>>, <<dimension-token>>,
		or a <<calc()>>,
		[=throw=] a {{SyntaxError}}
		and abort this algorithm.

	3. If |result| is a <<dimension-token>>, <<number-token>>, or <<percentage-token>>,
		return a new {{CSSUnitValue}} object
		with its value set to the token's value,
		and the unit set to the token's unit if it's a <<dimension-token>>,
		or `"number"` if it is a <<number-token>>,
		or `"percentage"` if it is a <<percentage-token>>.

	4. If |result| is a <<calc()>>,
		normalize the ''calc()'' argument
		into a sum of values with unique units,
		then return a {{CSSCalcValue}} object,
		with keys for each unit in the calc,
		and values set to the corresponding numeric values.
</div>

<div algorithm="CSSNumericValue.to()">
	The <dfn method for=CSSNumericValue>to(|unit|)</dfn> method converts an existing {{CSSNumericValue}}
	into another one with the specified |unit|.
	When called, it must perform the following steps:

	1. If |unit| does not have a [=CSS type=],
		[=throw=] a {{SyntaxError}}
		and abort this algorithm.

	2. If |this| is a {{CSSUnitValue}}
		and |this|’s unit and |unit| are [=compatible units=],
		return a new {{CSSUnitValue}}
		with its unit set to |unit|
		and its value set to |this|’s value
		multiplied by the conversion ratio between the two units.

	3. If |this| is a {{CSSCalcValue}}
		and all of its keys
		are [=compatible units=] with |unit|,
		return a new {{CSSUnitValue}}
		with its unit set to |unit|
		and its value to the sum of
		each of |this|’s values
		multiplied by the corresponding conversion ratios
		between their key and |unit|.

	4. Otherwise,
		[=throw=] a {{TypeError}}.
</div>

{{CSSNumericValue}}s can be <dfn>strongly typed</dfn>
or <dfn>weakly typed</dfn> to a type,
or <dfn>untyped</dfn>.

A {{CSSUnitValue}} is [=weakly typed=] to its [=CSS type=]
if that [=CSS type=] is "percent" or "number".
It's [=strongly typed=] to its [=CSS type=] otherwise.
It's never [=untyped=].

A {{CSSCalcValue}} is [=strongly typed=] if its [=CSS type set=]
contains a value other than "percent" or "number",
to that value.
It's [=weakly typed=] if it's not [=strongly typed=],
but its [=CSS type set=] [=set/is not empty=].
It's [=untyped=] if its [=CSS type set=] [=set/is empty=].


<!--
██     ██ ██    ██ ████ ████████
██     ██ ███   ██  ██     ██
██     ██ ████  ██  ██     ██
██     ██ ██ ██ ██  ██     ██
██     ██ ██  ████  ██     ██
██     ██ ██   ███  ██     ██
 ███████  ██    ██ ████    ██
-->

### Value + Unit: {{CSSUnitValue}} objects ### {#simple-numeric}

Numeric values that can be expressed as a single unit
(or a naked number or percentage)
are represented as {{CSSUnitValue}}s.

<div class=example>
	For example, the value ''5px'' in a stylesheet
	will be represented by a {{CSSUnitValue}}
	with its `value` attribute set to `5`
	and its `unit` attribute set to `"px"`.

	Similarly, the value ''10'' in a stylesheet
	will be represented by a {{CSSUnitValue}}
	with its `value` attribute set to `10`
	and its `unit` attribute set to `"number"`.
</div>

<xmp class=idl>
	[Constructor(double value, DOMString unit)]
    interface CSSUnitValue : CSSNumericValue {
        attribute double value;
        attribute DOMString unit;
        readonly attribute DOMString type;
    };
</xmp>

<div algorithm="CSSUnitValue constructor(value, unit)">
	The <dfn constructor for=CSSUnitValue>CSSUnitValue(|value|, |unit|)</dfn> constructor must,
	when called,
	perform the following steps:

	1. If |unit| does not have a [=CSS type=],
		[=throw=] a {{SyntaxError}}
		and abort this algorithm.

	2. Return a new {{CSSUnitValue}}
		with its value set to |value|
		and its unit set to |unit|.
</div>

<div algorithm="CSSUnitValue.unit">
	The <dfn attribute for=CSSUnitValue>unit</dfn> attribute of a {{CSSUnitValue}} |this| must,
	on setting a value |unit|,
	perform the following steps:

	1. If |unit| does not have a [=CSS type=],
		[=throw=] a {{TypeError}}.

	2. Otherwise,
		set |this|’s internal {{CSSUnitValue/unit}} slot to |unit|.

	On reading,
	it must return the value of |this|’s internal {{CSSUnitValue/unit}} slot.
</div>

<div algorithm="CSSUnitValue.type">
    The <dfn attribute for=CSSUnitValue>type</dfn> attribute of a {{CSSUnitValue}} |this| must,
    on reading,
    return the [=CSS type=] of |this|’s {{CSSUnitValue/unit}}.
</div>

<div algorithm="CSS type of a unit">
    The <dfn>CSS type</dfn> of a string |unit| is:

    <dl class=switch>
        : |unit| is "number"
        :: "number"
        : |unit| is "percent"
        :: "percent"
        : |unit| is a <<length>> unit
        :: "length"
        : |unit| is an <<angle>> unit
        :: "angle"
        : |unit| is a <<time>> unit
        :: "time"
        : |unit| is a <<frequency>> unit
        :: "frequency"
        : |unit| is a <<resolution>> unit
        :: "resolution"
        : |unit| is a <<flex>> unit
        :: "flex"
        : anything else
        :: the string does not have a [=CSS type=]
    </dl>
</div>

A {{CSSUnitValue}} matches a CSS type production,
such as <<number>> or <<length>>,
if its equivalent CSS value
(with the same value and unit,
or similar with "number" and "percent")
matches that production.


<!--
 ██████     ███    ██        ██████    ███ ███
██    ██   ██ ██   ██       ██    ██  ██     ██
██        ██   ██  ██       ██       ██       ██
██       ██     ██ ██       ██       ██       ██
██       █████████ ██       ██       ██       ██
██    ██ ██     ██ ██       ██    ██  ██     ██
 ██████  ██     ██ ████████  ██████    ███ ███
-->

### Complex Numeric Values: {{CSSCalcValue}} objects ### {#complex-numeric}

Numeric values that can only be expressed with a combination of units
are represented as {{CSSCalcValue}}.
This is a Map-like value,
where each entry represents the value of one unit,
and the object as a whole represents the sum of its units.

<div class=example>
    For example,
    the CSS value ''calc(1em + 5px)''
    will be represented by a {{CSSCalcValue}}
    [=map/contains|containing=] <nobr>«[ "em" → 1, "px" → 5 ]»</nobr>.
</div>

<xmp class=idl>
[Constructor(record<DOMString, double> recordValue)]
interface CSSCalcValue : CSSNumericValue {
    maplike<DOMString, double>;
    CSSCalcValue set(DOMString unit, double value);
    readonly attribute DOMString type;
};
</xmp>

<div algorithm="CSSCalcValue(recordValue)">
	The <dfn constructor for=CSSCalcValue>CSSCalcValue(|recordValue|)</dfn> constructor must,
	when called,
	perform the following steps:

	1. Let |strongType| be initially null.

	2. [=map/For each=] unit → value of |recordValue|:

		1. If |unit| does not have a [=CSS type=],
			[=throw=] a {{TypeError}}.
		2. If |unit| is a [=strong type=],
			and |strongType| is null,
			let |strongType| be |unit|’s [=CSS type=].
		3. If |unit| is a [=strong type=],
			and |strongType| is not equal to that type,
			[=throw=] a {{TypeError}}.

	3. Return a new {{CSSCalcValue}} whose <a>map entries</a> are |recordValue|.
</div>

Issue: When IDL grows a map-iterator concept,
add a constructor that takes one.
It's supremely awkward to handle one manually right now.

<div algorithm="CSSCalcValue.set()">
    The <dfn method for=CSSCalcValue>set(|unit|, |value|)</dfn> method,
    when called on a {{CSSCalcValue}} |this|,
    must perform the following steps:

    1. Let |newType| be the [=CSS type=] of |unit|.
        If |unit| does not have a [=CSS type=],
        [=throw=] a {{TypeError}}.

    2. If |this| has no [=strong type=],
        or if |newType| is "percent", "number",
        or equal to |this|’s [=strong type=],
        [=map/set=] the key |unit| to the value |value| in |this|’s [=map entries=],
        and return |this|.

    3. Otherwise, [=throw=] a {{TypeError}}.
</div>

<div algorithm="CSSCalcValue.type">
    The <dfn attribute for=CSSCalcValue>type</dfn> attribute
    of a {{CSSCalcValue}} |this| must,
    on reading,
    must return the concatenation of the entries in |this|’s [=CSS type set=],
    each separated by a U+002D HYPHEN-MINUS (-) character.
    If there are multiple entries,
    they must be concatenated in the order:
    [=strong type=],
    "percent",
    "number".

    Note: This implies that if the [=CSS type set=] is empty
    (because |this| [=map/is empty=]),
    this attribute returns the empty string.
</div>

<div algorithm="CSS type set">
    The <dfn for=CSSCalcValue>CSS type set</dfn> of a {{CSSCalcValue}} |this|
    is an [=ordered set=]
    that contains the [=CSS types=] of every key
    [=map/contains|contained=] in |this|’s [=map entries=].

    Note: The [=CSS type set=] will contain at most 3 entries;
    "percent", "number",
    and this {{CSSCalcValue}}’s [=strong type=].
</div>

A {{CSSCalcValue}} has a <dfn for=CSSCalcValue>strong type</dfn>
if its [=CSS type set=] [=set/contains=] a value other than "percent" or "number",
equal to that other value.

A {{CSSCalcValue}} matches a CSS type production,
such as <<number>> or <<length-percentage>>,
if its equivalent CSS ''calc()'' value matches that production.

<!--
████████ ████████     ███    ██    ██  ██████  ████████  ███████  ████████  ██     ██
   ██    ██     ██   ██ ██   ███   ██ ██    ██ ██       ██     ██ ██     ██ ███   ███
   ██    ██     ██  ██   ██  ████  ██ ██       ██       ██     ██ ██     ██ ████ ████
   ██    ████████  ██     ██ ██ ██ ██  ██████  ██████   ██     ██ ████████  ██ ███ ██
   ██    ██   ██   █████████ ██  ████       ██ ██       ██     ██ ██   ██   ██     ██
   ██    ██    ██  ██     ██ ██   ███ ██    ██ ██       ██     ██ ██    ██  ██     ██
   ██    ██     ██ ██     ██ ██    ██  ██████  ██        ███████  ██     ██ ██     ██
-->

{{CSSTransformValue}} objects {#transformvalue-objects}
-----------------------------------------------------------

<xmp class='idl'>
    [Constructor(),
     Constructor(sequence<CSSTransformComponent> transforms)]
    interface CSSTransformValue : CSSStyleValue {
    	iterable<CSSTransformComponent>;
    	readonly attribute boolean is2D;
    	readonly attribute DOMMatrixReadOnly matrix;
    };
</xmp>

{{CSSTransformValue}} objects represent values for the 'transform' property. A
{{CSSTransformValue}} represents a list of {{CSSTransformComponent}}s.

<dfn attribute for=CSSTransformValue>is2D</dfn> is true if the {{CSSTransformComponent/is2D}}
attribute of every {{CSSTransformComponent}} referenced by the {{CSSTransformValue}}
returns true, and false otherwise.

<xmp class=idl>
    interface CSSTransformComponent {
    	readonly attribute DOMString cssText;
    	readonly attribute boolean is2D;
    };

    [Constructor(CSSNumericValue x, CSSNumericValue y),
     Constructor(CSSNumericValue x, CSSNumericValue y, CSSNumericValue z)]
    interface CSSTranslation : CSSTransformComponent {
    	attribute CSSNumericValue x;
    	attribute CSSNumericValue y;
    	attribute CSSNumericValue z;
    };

    [Constructor(CSSNumericValue angle),
     Constructor(double x, double y, double z, CSSNumericValue angle)]
    interface CSSRotation : CSSTransformComponent {
    	attribute double x;
    	attribute double y;
    	attribute double z;
    	attribute CSSNumericValue angle;
    };

    [Constructor(double x, double y),
     Constructor(double x, double y, double z)]
    interface CSSScale : CSSTransformComponent {
    	attribute double x;
    	attribute double y;
    	attribute double z;
    };

    [Constructor(CSSNumericValue ax, CSSNumericValue ay)]
    interface CSSSkew : CSSTransformComponent {
    	attribute CSSNumericValue ax;
    	attribute CSSNumericValue ay;
    };

    [Constructor(CSSNumericValue length)]
    interface CSSPerspective : CSSTransformComponent {
    	attribute CSSNumericValue length;
    };

    [Constructor(DOMMatrixReadOnly matrix)]
    interface CSSMatrixComponent : CSSTransformComponent {
    	attribute DOMMatrix matrix;
    };
</xmp>

{{CSSTransformComponent}} objects have the following properties:

<div algorithm="CSSTransformComponent/is2D">
	The <dfn attribute for=CSSTransformComponent>is2D</dfn> attribute is
	true if the component represents a 2D transform function,
	and false otherwise.

	This is only true for:

	* {{CSSTranslation}} objects if their {{CSSTranslation/z}} attribute is 0
	* {{CSSRotation}} objects if their {{CSSRotation/x}} and {{CSSRotation/y}} attributes are 0
	* {{CSSScale}} objects if their {{CSSScale/z}} attribute is 1
	* {{CSSSkew}} objects at all times
	* {{CSSPerspective}} objects never.
	* {{CSSMatrixComponent}} objects if their {{CSSMatrixComponent/matrix}}’s [=DOMMatrixReadonly/is2D=] flag is true.
</div>

The transform function which the component represents
is stored in string form in the <dfn attribute for=CSSTransformComponent>cssText</dfn> attribute.

<div class=note>
    Each {{CSSTransformComponent}} can correspond to one of a number of underlying
    transform functions. For example, a {{CSSTranslation}} with an x value of "10px"
    and y &amp; z values of 0 could be:

    *   translate(10px)
    *   translate(10px, 0)
    *   translateX(10px)
    *   translate3d(10px, 0, 0)
</div>

When a {{CSSTransformValue}} is read from a {{StylePropertyMap}}, each
{{CSSTransformComponent}} will maintain the relevant transform function in
its <code>cssText</code> attribute. However, newly constructed {{CSSTransformValue}}s
will always generate <code>cssText</code> according to the following rules:
*   {{CSSSkew}} will always serialize to skew(ax, ay)
*   {{CSSPerspective}} will always serialize to perspective(length)
*   {{CSSTranslation}}, {{CSSRotation}}, and {{CSSScale}} each have two
		constructors. In each case, the constructor with fewer arguments constructs
		a {{CSSTransformComponent}} for which {{CSSTransformComponent/is2D}} will be true,
		with <code>cssText</code> employing the 2D version of the relevant transform
		function (translate, rotate, scale). The constructor with more
		arguments constructs a {{CSSTransformComponent}} for which
		{{CSSTransformComponent/is2D}} will be false, with <code>cssText</code>
		employing the 3D version of the relevant transform function (translate3d,
		rotate3d, scale3d).
*   {{CSSMatrixComponent}} objects are constructed around a {{DOMMatrixReadOnly}}, and
		will serialize to a matrix function if the contained {{DOMMatrixReadOnly}}'s
		{{DOMMatrixReadOnly/is2D}} attribute is false, and a matrix3d function
		otherwise.

<!--
████████   ███████   ██████  ████ ████████ ████  ███████  ██    ██
██     ██ ██     ██ ██    ██  ██     ██     ██  ██     ██ ███   ██
██     ██ ██     ██ ██        ██     ██     ██  ██     ██ ████  ██
████████  ██     ██  ██████   ██     ██     ██  ██     ██ ██ ██ ██
██        ██     ██       ██  ██     ██     ██  ██     ██ ██  ████
██        ██     ██ ██    ██  ██     ██     ██  ██     ██ ██   ███
██         ███████   ██████  ████    ██    ████  ███████  ██    ██
-->

{{CSSPositionValue}} objects {#positionvalue-objects}
--------------------------------------------------

<pre class='idl'>

[Constructor(CSSNumericValue x, CSSNumericValue y)]
interface CSSPositionValue : CSSStyleValue {
	attribute CSSNumericValue x;
	attribute CSSNumericValue y;
};

</pre>

{{CSSPositionValue}} objects represent values for properties that take <<position>>
productions, for example 'background-position'.

The <dfn attribute for=CSSPositionValue>x</dfn> attribute contains the position offset
from the left edge of the container, expressed as a length.

The <dfn attribute for=CSSPositionValue>y</dfn> attribute contains the position offset
from the top edge of the container, expressed as a length.

Note that <<position>> productions accept a complicated combination of keywords
and values. When specified as such in a stylesheet or via the untyped CSSOM,
the {{CSSStyleValue/cssText}} attribute will contain the specified
string. However, this string is normalized as two Lengths into the {{CSSPositionValue/x}} and {{CSSPositionValue/y}} values of the
{{CSSStyleValue}} object.

New {{CSSPositionValue}} objects can only be constructed via pairs of lengths, and
will only return the direct serialization of these lengths in the
{{CSSStyleValue/cssText}} attribute.

<div class='example'>

For example, the following style sheet:

<pre class='style'>
.example {
	background-position: center bottom 10px;
}
</pre>

Will produce the following behavior:

<pre class='lang-javascript'>
// "center bottom 10px"
document.querySelector('.example').styleMap.get('background-position').cssText;

// 50% - as a CSSUnitValue
document.querySelector('.example').styleMap.get('background-position').x;

// calc(100% - 10px) - as a CSSCalcLength
document.querySelector('.example').styleMap.get('background-position').y;
</pre>

</div>

<!--
████████  ████████  ██████   ███████  ██     ██ ████████   ██████  ████████
██     ██ ██       ██    ██ ██     ██ ██     ██ ██     ██ ██    ██ ██
██     ██ ██       ██       ██     ██ ██     ██ ██     ██ ██       ██
████████  ██████    ██████  ██     ██ ██     ██ ████████  ██       ██████
██   ██   ██             ██ ██     ██ ██     ██ ██   ██   ██       ██
██    ██  ██       ██    ██ ██     ██ ██     ██ ██    ██  ██    ██ ██
██     ██ ████████  ██████   ███████   ███████  ██     ██  ██████  ████████
-->

{{CSSResourceValue}} objects {#resourcevalue-objects}
-----------------------------------------------------

<pre class='idl'>
enum CSSResourceState {"unloaded", "loading", "loaded", "error"};

interface CSSResourceValue : CSSStyleValue {
	readonly attribute CSSResourceState state;
};

</pre>

{{CSSResourceValue}} objects represent CSS values that may require an asynchronous network fetch
before being usable.

A {{CSSResourceValue}} is in one of the following states, as reflected in the value of the
{{CSSResourceValue/state}} attribute:

:   "unloaded"
::  The resource is not ready and is not actively being fetched
:   "loading"
::  The resource is not ready, but is in the process of being fetched
:   "loaded"
::  The resource is ready for rendering
:   "error"
::  The resource can't be fetched, or the fetched resource is invalid

<div class='example'>
For example, images that match the <<url>> production can be used immediately, but will not result
in a visual change until the image data is fetched. {{CSSResourceValue}} objects represent this by
providing values that track loaded state via the {{CSSResourceState}} enum.
</div>

<!--
████ ██     ██    ███     ██████   ████████
 ██  ███   ███   ██ ██   ██    ██  ██
 ██  ████ ████  ██   ██  ██        ██
 ██  ██ ███ ██ ██     ██ ██   ████ ██████
 ██  ██     ██ █████████ ██    ██  ██
 ██  ██     ██ ██     ██ ██    ██  ██
████ ██     ██ ██     ██  ██████   ████████
-->

{{CSSImageValue}} objects {#imagevalue-objects}
-----------------------------------------------

<pre class='idl'>
interface CSSImageValue : CSSResourceValue {
	readonly attribute double? intrinsicWidth;
	readonly attribute double? intrinsicHeight;
	readonly attribute double? intrinsicRatio;
};

[Constructor(DOMString url)]
interface CSSURLImageValue : CSSImageValue {
	readonly attribute DOMString url;
};

</pre>

{{CSSImageValue}} objects represent values for properties that take <<image>> productions,
for example 'background-image', 'list-style-image', and 'border-image-source'.

{{CSSImageValue}} objects that do not require network data (for example linear and radial gradients)
are initialized with {{CSSResourceValue/state}} "loaded".

If the {{CSSImageValue}}'s {{CSSResourceValue/state}} is "loaded",
and the resource has an intrinsic width, height, or aspect ratio,
then {{CSSImageValue/intrinsicWidth}}, {{CSSImageValue/intrinsicHeight}}, and {{CSSImageValue/intrinsicRatio}} must reflect the resource's corresponding value.
In all other cases, the attributes must be <code>null</code>.

Issue: Does the loading lifecycle need to be described here?

{{CSSURLImageValue}} objects represent {{CSSImageValue}}s that match the <<url>> production. For these
objects, the {{CSSURLImageValue/url}} attribute contains the URL that references the image.

<!--
████████  ███████  ██    ██ ████████ ████████    ███     ██████  ████████
██       ██     ██ ███   ██    ██    ██         ██ ██   ██    ██ ██
██       ██     ██ ████  ██    ██    ██        ██   ██  ██       ██
██████   ██     ██ ██ ██ ██    ██    ██████   ██     ██ ██       ██████
██       ██     ██ ██  ████    ██    ██       █████████ ██       ██
██       ██     ██ ██   ███    ██    ██       ██     ██ ██    ██ ██
██        ███████  ██    ██    ██    ██       ██     ██  ██████  ████████
-->

{{CSSFontFaceValue}} objects {#fontfacevalue-objects}
-----------------------------------------------------

<pre class='idl'>

[Constructor(DOMString fontFamilyName)]
interface CSSFontFaceValue : CSSResourceValue {
	readonly attribute DOMString fontFamilyName;
};

</pre>

{{CSSFontFaceValue}} objects are opaque representations of the contents of
@font-face rules. They are used to pass font information into [=paint image definition=]s,
via [=custom properties=].

As font data may need to be fetched from a remote source, {{CSSFontFaceValue}} is a subclass
of {{CSSResourceValue}}.

Issue(159): Spec up ColorValue

<!--
 ██████   ██████   ██████                ██           ███████  ██     ██
██    ██ ██    ██ ██    ██                ██         ██     ██ ███   ███
██       ██       ██                       ██        ██     ██ ████ ████
██        ██████   ██████        ███████    ██       ██     ██ ██ ███ ██
██             ██       ██                 ██        ██     ██ ██     ██
██    ██ ██    ██ ██    ██                ██         ██     ██ ██     ██
 ██████   ██████   ██████                ██           ███████  ██     ██
-->

{{CSSStyleValue}} normalization {#stylevalue-normalization}
===========================================================

This section describes how Typed OM objects are constructed from CSS values.

If a property's grammar is more complex than one of the types listed here,
it produces a raw {{CSSStyleValue}},
with its {{CSSStyleValue/cssText}}
set to the CSSOM serialization of the property.

Issue: Better to define a full table of properties and what types they normalize to.

Issue: Per F2F, "CSSOM serialization" isn't well-defined/interoperable enough.
We instead need to strictly define the serialization of every property.
This should be done according to CSSOM principlies, tho
(generally, shortest possible value).

Raw CSS tokens: properties with ''var()'' references {#normalize-tokens}
--------------------------------------------------

Regardless of what the property's grammar is otherwise,
a property value with an un-substituted ''var()'' reference
is represented as a [=list=] of [=component values=],
which becomes a {{CSSUnparsedValue}} in the Typed OM.

<div algorithm>
	To <dfn export>normalize a list of component values</dfn>
	from a |list|:

	1. Replace all ''var()'' references in |list|
		with {{CSSVariableReferenceValue}} objects,
		as described in [[#normalize-var]].
	2. Replace each remaining maximal subsequence of [=component values=] in |list|
		with a single string of their concatenated serializations.
	3. Return a new {{CSSUnparsedValue}}
		whose {{CSSUnparsedValue/[[tokens]]}} slot is set to |list|.
</div>

<div class='example'>
The string "calc(42px + var(--foo, 15em) + var(--bar, var(--far) + 15px))"
is converted into a {{CSSUnparsedValue}} that contains a sequence with:

	* the string "calc(42px + "
	* a {{CSSVariableReferenceValue}} with:
		* {{CSSVariableReferenceValue/variable}} "--foo"
		* {{CSSVariableReferenceValue/fallback}} a
			{{CSSUnparsedValue}} with a single-valued sequence containing " 15em"
	* the string " + "
	* a {{CSSVariableReferenceValue}} with:
		* {{CSSVariableReferenceValue/variable}} "--bar"
		* {{CSSVariableReferenceValue/fallback}} a {{CSSUnparsedValue}}
			with a sequence containing:
			* the string " "
			* a {{CSSVariableReferenceValue}} with
				* {{CSSVariableReferenceValue/variable}} "--far"
				* {{CSSVariableReferenceValue/fallback}} null
			* the string " + 15px"
	* the string ")"
</div>

''var()'' References {#normalize-var}
-------------------------------------

''var()'' references become {{CSSVariableReferenceValue}}s in the Typed OM.

<div algorithm>
	To <dfn dfn export>normalize a ''var()'' reference</dfn> |var|:

	1. Let |object| be a new {{CSSVariableReferenceValue}}.

	2. Set |object|’s {{CSSVariableReferenceValue/variable}} internal slot
		to the serialization of the <<custom-ident>> providing the variable name.

	3. If |var| has a fallback value,
		set |object|’s {{CSSVariableReferenceValue/fallback}} internal slot
		to the result of [=normalize a list of component values|normalizing the fallback's component values=].
		Otherwise,
		set it to `null`.

	4. Return |object|.
</div>

[=Identifier=] Values {#normalize-ident}
-----------------------------------

CSS [=identifiers=] become {{CSSKeywordValue}}s in the Typed OM.

<div algorithm>
	To <dfn export>normalize an [=identifier=]</dfn> |ident|:

	1. Return a new {{CSSKeywordValue}}
		with its {{CSSKeywordValue/value}} internal slot
		set to the serialization of |ident|.
</div>

{{CSSNumericValue}} normalization {#numericvalue-normalization}
-------------------------------------------------------------

Issue: todo

{{CSSTransformValue}} normalization {#transformvalue-normalization}
-------------------------------------------------------------------

If the provided value matches the <<transform-list>> production then a {{CSSTransformComponent}}
is constructed for each matching <<transform-function>> in the production, and a {{CSSTransformValue}}
is constructed around the resulting sequence.

Otherwise, if the provided value is "none", an empty string, or a string containing only whitespace,
then a {{CSSTransformValue}} is constructed around an empty sequence.

Otherwise, normalization fails.

<div class='example'>
The string "scale(2, 0.5) translate(100px) rotate(20deg)"
is converted into a {{CSSTransformValue}} that contains a list of {{CSSTransformComponent}} with:
*   a {{CSSScale}} with:
		*   {{CSSScale/x}} set to 2
		*   {{CSSScale/y}} set to 0.5
*   a {{CSSTranslation}} with:
		*   {{CSSTranslation/x}} with {{CSSUnitValue/value}} of `100` and {{CSSUnitValue/unit}} of `"px"`
*   a {{CSSRotation}} with:
		*   {{CSSRotation/angle}} with {{CSSUnitValue/value}} of `20` and {{CSSUnitValue/unit}} of `"deg"`

</div>

{{CSSPositionValue}} normalization {#positionvalue-normalization}
-----------------------------------------------------------------

If the provided value matches the <<position>> production, then a {{CSSPositionValue}} is constructed
with <var>x</var> and <var>y</var> components determined via the following process. If this process, or
any sub-process referenced by this process fails, then normalization as a whole fails.

1.  Initialize both <var>x</var> and <var>y</var> to a {{CSSNumericValue}} value representing 50%.
1.  If the provided value is a single keyword, length, percentage, or calc expression, then follow
		the procedure outlined in [[#from-single-keyword]] with <var>value</var> given
		by the provided value and a horizontal <var>bias</var>.
1.  Otherwise, if the provided value consists of a combination of two keywords, then:

		1.  follow the procedure outlined in [[#from-single-keyword]] with <var>value</var> given by the
				first keyword and an auto <var>bias</var>.
		1.  if <var>bias</var> is horizontal, set it to vertical. Otherwise, set it to horizontal.
		1.  follow the procedure again with <var>value</var> given by the second keyword, using the existing <var>bias</var>.

1.  Otherwise, if the provided value consists of a combination of two keywords, lengths, percentages, and
		calc expressions, then follow the procedure outlined in [[#from-single-keyword]] with
		<var>value</var> given by the first part of the provided value and a horizontal <var>bias</var>, then follow the
		procedure again with <var>value</var> given by the second part of the provided value and a vertical <var>bias</var>.
1.  Otherwise:

		1.  if the provided value starts with a keyword followed by a length, percentage, or calc expression, then follow
				the procedure outlined in [[#from-keyword-and-length]] with <var>keyword</var> set to the
				keyword, <var>length</var> set to the length, percentage, or calc expression, and auto <var>bias</var>.
		1.  otherwise, follow the procedure outlined in [[#from-single-keyword]] with <var>value</var>
				set to the first component of the provided value and an auto <var>bias</var>.
		1.  if <var>bias</var> is horizontal, set it to vertical. Otherwise, set it to horizontal.
		1.  if the remainder of the provided value is a single keyword, length, percentage or calc expression, follow
				the procedure outlined in
				[[#from-single-keyword]] with <var>value</var> set to the keyword and the existing
				<var>bias</var>.
		1.  otherwise, if the remainder of the provided value consists of a keyword followed by a length, percentage or
				calc expression, follow the procedure outlined in [[#from-keyword-and-length]] with
				<var>keyword</var> set to the keyword, <var>length</var> set to the length, percentage, or calc expression, and
				the existing <var>bias</var>.
		1.  Otherwise, the process fails.

<h4 id='from-single-keyword'>Determining <var>x</var> or <var>y</var> from a single value</h4>

The following process sets a value for either <var>x</var> or <var>y</var>, depending on an input <var>value</var>
and <var>bias</var>. The process also updates <var>bias</var> based on the <var>value</var>.

1.  If <var>value</var> is the keyword "left" and <var>bias</var> is not vertical, then set <var>x</var> to a
		{{CSSNumericValue}} value representing 0% and <var>bias</var> to horizontal and exit this process.
1.  If <var>value</var> is the keyword "right" and <var>bias</var> is not vertical, then set <var>x</var> to a
		{{CSSNumericValue}} value representing 100% and <var>bias</var> to horizontal and exit this process.
1.  If <var>value</var> is the keyword "top" and <var>bias</var> is not horizontal, then set <var>y</var> to a
		{{CSSNumericValue}} value representing 0% and <var>bias</var> to vertical and exit this process.
1.  If <var>value</var> is the keyword "bottom" and <var>bias</var> is not horizontal, then set <var>y</var> to a
		{{CSSNumericValue}} value representing 100% and <var>bias</var> to vertical and exit this process.
1.  If <var>value</var> matches the <<length-percentage>> production, then set <var>norm</var> to the result of
		normalizing the value according to [[#numericvalue-normalization]]. If <var>bias</var> is vertical,
		set <var>y</var> to <var>norm</var>, otherwise set <var>x</var> to <var>norm</var> and <var>bias</var> to
		horizontal. Exit this process.
1.  If <var>value</var> is not the keyword "center", then this process fails.

<h4 id='from-keyword-and-length'>Determining <var>x</var> or <var>y</var> from a keyword and a length</h4>

The following process sets a value for either <var>x</var> or<var>y</var>, depending on an input <var>keyword</var>,
<var>length</var>, and <var>bias</var>. The process also updates <var>bias</var> based on the <var>keyword</var> and
<var>length</var>.

1.  follow the procedure outlined in [[#from-single-keyword]] with <var>value</var> given by
		<var>keyword</var>, using the provided <var>bias</var>
1.  let <var>adjustment</var> be the result of normalizing <var>length</var> according to
		[[#numericvalue-normalization]].
1.  If the keyword is "right" or "bottom", let <var>adjustment</var> be the result of subtracting
		<var>adjustment</var> from a zero length.
1.  amend <var>x</var> (if <var>bias</var> is horizontal) or <var>y</var> (if <var>bias</var> is vertical) by
		adding <var>adjustment</var> to it.

{{CSSResourceValue}} normalization {#resourcevalue-normalization}
--------------------------------------------------------------

Resource references are normalized by determining whether the reference is invalid
(in which case {{CSSResourceValue/state}} is set to ''error'') or
requires network data (in which case {{CSSResourceValue/state}}
is set to ''loading''). If data is not required and the reference is valid then
{{CSSResourceValue/state}} is set to ''loaded''.

If {{CSSResourceValue/state}} is set to ''loading'' then the image
reference is reevaluated once the pending data becomes available, according to the
same rules referenced above.

Normalization does not fail for {{CSSResourceValue}} objects.

<div class='example'>
The string 'url(''bike.png'')' is converted into a {{CSSURLImageValue}} with {{CSSResourceValue/state}} set to ''unloaded'' and the {{CSSURLImageValue/url}} set to ''https://drafts.css-houdini.org/css-typed-om/bike.png''. The {{CSSImageValue/intrinsicWidth}}, {{CSSImageValue/intrinsicHeight}} and {{CSSImageValue/intrinsicRatio}} are all set to null.
</div>

<!--
 ██████  ████████ ████████  ████    ███    ██       ████ ████████    ███    ████████ ████  ███████  ██    ██
██    ██ ██       ██     ██  ██    ██ ██   ██        ██       ██    ██ ██      ██     ██  ██     ██ ███   ██
██       ██       ██     ██  ██   ██   ██  ██        ██      ██    ██   ██     ██     ██  ██     ██ ████  ██
 ██████  ██████   ████████   ██  ██     ██ ██        ██     ██    ██     ██    ██     ██  ██     ██ ██ ██ ██
      ██ ██       ██   ██    ██  █████████ ██        ██    ██     █████████    ██     ██  ██     ██ ██  ████
██    ██ ██       ██    ██   ██  ██     ██ ██        ██   ██      ██     ██    ██     ██  ██     ██ ██   ███
 ██████  ████████ ██     ██ ████ ██     ██ ████████ ████ ████████ ██     ██    ██    ████  ███████  ██    ██
-->

{{CSSStyleValue}} Serialization {#stylevalue-serialization}
===========================================================

The way that a {{CSSStyleValue}} serializes is dependent on how the value was constructed.

:   if the value was constructed from a DOMString
::  the serialization is the DOMString from which the value was constructed.
:   otherwise, if the value was constructed using an IDL constructor
::  the serialization is specified in the sections below.
:   otherwise, if the value was extracted from the CSSOM
::  the serialization matches the CSSOM serialization of the corresponding value.

<div class='example'>

For example:

<pre class='lang-javascript'>
var length1 = CSSNumericValue.from("42.0px");
length1.cssText; // "42.0px"

var length2 = CSSNumericValue.from(42.0, "px");
length2.cssText; // "42px";

element.style.width = "42.0px";
var length3 = element.styleMap.get('width');
length3.cssText; // "42px";
</pre>

</div>

{{CSSUnparsedValue}} Serialization {#unparsedvalue-serialization}
-----------------------------------------------------------------

{{CSSUnparsedValue}} objects are serialized by first serializing each
{{CSSVariableReferenceValue}}, then concatenating the contained DOMStrings and
{{CSSVariableReferenceValue}} serializations in order.

{{CSSVariableReferenceValue}} objects are serialized by the following process:
1.  the fallback {{CSSUnparsedValue}} is serialized
2.  if the fallback serialization is the empty string, then the
    {{CSSVariableReferenceValue}} serializes as "var(" + variable + ")"
3.  otherwise, the {{CSSVariableReferenceValue}} serializes as
    "var(" + variable + "," + fallback serialization + ")"

{{CSSKeywordValue}} Serialization {#keywordvalue-serialization}
---------------------------------------------------------------

{{CSSKeywordValue}} objects are serialized to their contained
{{CSSKeywordValue/value}} attribute.

{{CSSUnitValue}} Serialization {#numericvalue-serialization}
--------------------------------------------------------------

If their {{CSSUnitValue/unit}} is "number",
{{CSSUnitValue}} objects are serialized
to the string representation of their {{CSSUnitValue/value}}.

Otherwise, if their {{CSSUnitValue/unit}} is "percent",
{{CSSUnitValue}} objects are serialized
to the string representation of their {{CSSUnitValue/value}}
followed by the character U+0025 PERCENTAGE SIGN (%).

Otherwise,
{{CSSUnitValue}} objects are serialized
to the string representation of their {{CSSUnitValue/value}}
followed by their {{CSSUnitValue/unit}}.

{{CSSCalcValue}} Serialization {#calc-serialization}
---------------------------------------------------------

{{CSSCalcValue}} objects are serialized into a ''calc()'' expression,
per the rules in [[css-values-3#calc-serialize]],
treating the object as a summation of all the non-`null` values it contains.

{{CSSTransformValue}} Serialization {#transformvalue-serialization}
-------------------------------------------------------------------

{{CSSTransformValue}} objects are serialized by generating a space-separated list
of serializations of the contained {{CSSTransformComponent}} objects.

{{CSSTransformComponent}} objects are serialized according to the following rules:

*   For all objects except {{CSSMatrixComponent}} objects, the serialization
    is defined by the object constructors.
*   When there are multiple constructors for a {{CSSMatrixComponent}} object, then
    if the {{CSSTransformComponent/is2D}} attribute is set to true,
    then the relevant constructor is the constructor with fewer arguments; otherwise
    the relevant constructor is the constructor with more arguments.
*   Each serialization is represented by a function
*   The function's name is a lowercase version of the component object type,
    without the CSS prefix
*   The function's arguments are a comma-separated list that matches the
    arguments to the relevant constructor. The values of the arguments are given
    by the attributes contained in the {{CSSTransformComponent}}.
*   {{CSSNumericValue}} attributes serialize using the rules above.
	Doubles serialize to their string representation.
*   {{CSSMatrixComponent}} objects serialize to a list of 6 components if
    {{CSSTransformComponent/is2D}} is set, or 12 components otherwise.
    Component order and format is given by [[CSS-TRANSFORMS-1]].

{{CSSPositionValue}} Serialization {#positionvalue-serialization}
-----------------------------------------------------------------

{{CSSPositionValue}} objects are serialized by:
*   serializing the {{CSSPositionValue/x}} attribute according to
    the rules for {{CSSNumericValue}} objects above.
*   serializing the {{CSSPositionValue/y}} attribute according to
    the rules for {{CSSNumericValue}} objects above.
*   returning the concatenation of the two serializations (x before y), separated
    by a space.

{{CSSURLImageValue}} Serialization {#urlimagevalue-serialization}
-----------------------------------------------------------

{{CSSURLImageValue}} objects are serialized to the string given by
"url(" + {{CSSURLImageValue/url}} + ")".

{{CSSFontFaceValue}} Serialization {#fontfacevalue-serialization}
-----------------------------------------------------------------

{{CSSFontFaceValue}} objects are serialized to the value of their contained
{{CSSFontFaceValue/fontFamilyName}}.

Security Considerations {#security-considerations}
==================================================

There are no known security issues introduced by these features.

Privacy Considerations {#privacy-considerations}
==================================================

There are no known privacy issues introduced by these features.

<!--
 ██████   ███████  ██     ██ ████████  ██     ██ ████████ ████████ ████████
██    ██ ██     ██ ███   ███ ██     ██ ██     ██    ██    ██       ██     ██
██       ██     ██ ████ ████ ██     ██ ██     ██    ██    ██       ██     ██
██       ██     ██ ██ ███ ██ ████████  ██     ██    ██    ██████   ██     ██
██       ██     ██ ██     ██ ██        ██     ██    ██    ██       ██     ██
██    ██ ██     ██ ██     ██ ██        ██     ██    ██    ██       ██     ██
 ██████   ███████  ██     ██ ██         ███████     ██    ████████ ████████
-->

Appendix A: Computed {{CSSStyleValue}} objects {#computed-stylevalue-objects}
=============================================================================

This appendix describes the restrictions on {{CSSStyleValue}} objects that
appear as computed values (i.e. as a value stored on computed
{{StylePropertyMapReadOnly}} objects).

Computed {{CSSUnparsedValue}} objects {#computed-unparsedvalue-objects}
-----------------------------------------------------------------------------

A property with a declared {{CSSUnparsedValue}} value will not
compute to a {{CSSUnparsedValue}}. Instead, after custom property references
are resolved, the {{CSSStyleValue}} subclass appropriate to the property will be
used.

<div class='example'>
For example, a style rule containing:

<pre class='style'>
width: calc(var(--foo) + 10%);
</pre>

Will represent a declared width as an {{CSSUnparsedValue}}, but if this value
is the winning value during computation for a given element then that element's
computed width will be represented by a {{CSSNumericValue}} object (assuming
that --foo resolves to a valid substitution).
</div>

Often there will be no {{CSSStyleValue}} subclass appropriate - for example when a custom property
contains a reference to another custom property. In these cases, a {{CSSStyleValue}}
is used directly to represent a value of unknown type.

<div class='example'>

For example, a style rule containing:

<pre class='style'>
--foo: var(--bar) black;
</pre>

Will represent a declared value for --foo as a {{CSSUnparsedValue}}, and if
this value is the winning declaration for --foo during computation for a given
element, then that element's will have a computed value for --foo that is
represented by a {{CSSStyleValue}}.
</div>

Computed {{CSSKeywordValue}} objects {#computed-keywordvalue-objects}
---------------------------------------------------------------------

During computation, {{CSSKeywordValue}} objects are either as specified (e.g. ''auto''
values for lengths that participate in layout) or resolved to a relevant value
and renormalized (e.g. the color ''red'').

Computed {{CSSUnitValue}} objects {#computed-numericvalue-objects}
---------------------------------------------------------------------

During computation, {{CSSUnitValue}} objects
are range-restricted or rounded as appropriate to the relevant property,
but otherwise as specified.

Computed {{CSSCalcValue}} objects {#computed-calc-objects}
-----------------------------------------------------------------

During computation, {{CSSCalcValue}} objects are reduced accordingly:

1. All non-`number`, non-`percent` values are absolutized
	into the [=canonical unit=] for the object's associated type.
2. If the objects contains exactly one of (the canonical unit, a percent value, a number)
	with a present, non-zero value,
	then the computed value is an equivalent computed {{CSSUnitValue}}.
3. Otherwise,
	it's a {{CSSCalcValue}}
	containing the canonical unit, percent value, and number,
	if those are present and non-zero,
	and all other fields are `null`.

Computed {{CSSTransformValue}} objects {#computed-transformvalue-objects}
-------------------------------------------------------------------------

During computation, any {{CSSNumericValue}} objects referenced by a {{CSSTransformComponent}}
(e.g. the {{CSSTranslation/x}} attribute of a {{CSSTranslation}}) are
computed according to [[#computed-numericvalue-objects]], but the
{{CSSTransformValue}} object is otherwise as specified.

Computed {{CSSPositionValue}} objects {#computed-positionvalue-objects}
-----------------------------------------------------------------------

During computation, both the {{CSSPositionValue/x}} and
{{CSSPositionValue/y}} components of a {{CSSPositionValue}} are
computed according to [[#computed-numericvalue-objects]].

Computed {{CSSImageValue}} objects {#computed-imagevalue-objects}
-----------------------------------------------------------------

Computed {{CSSImageValue}} objects are as specified.

Computed {{CSSFontFaceValue}} objects {#computed-fontfacevalue-objects}
---------------------------------------------------------------

Computed {{CSSFontFaceValue}} objects are as specified.
