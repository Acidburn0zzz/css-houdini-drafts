<pre class='metadata'>
Title:  CSS Properties and Values API Level 1
Status: DREAM
Group: houdini
ED: https://drafts.css-houdini.org/css-properties-values-api-1/
Shortname: css-properties-values-api
Level: 1
Abstract: This CSS module defines an API for registering new CSS properties. Properties registered using this API are provided with a parse syntax that defines a type, inheritance behaviour, and a default value.
Editor: Tab Atkins, jackalmage@gmail.com
Editor: Shane Stephens, shanestephens@google.com
Editor: Daniel Glazman, daniel.glazman@disruptive-innovations.com
Editor: Elliot Sprehn, esprehn@chromium.org
Editor: Greg Whitworth, gwhit@microsoft.com
Ignored Terms: boolean, Animatable, Map, Context, isolated worker, SyntaxError, InvalidModificationError, NotFoundError
Repository: w3c/css-houdini-drafts
At Risk: the apply hook (<a section href="#the-apply-hook"></a>)
</pre>

<pre class='biblio'>
{
  "css-paint-api": {
    "title": "CSS Painting API"
  },
  "css-layout-api": {
    "title": "CSS Layout API"
  }
}
</pre>

Introduction {#intro}
=====================

CSS defines a comprehensive set of properties that can be manipulated in order
to modify the layout, paint, or behaviour of a web document. However, web authors
frequently wish to extend this set with additional properties.

[[css-variables]] provides primitive means for defining user-controlled properties,
however these properties always take token lists as values, must always inherit, and
can only impact document layout or paint by being re-incorporated into the value
of other properties via a var() reference.

This specification extends [[css-variables]], allowing the registration of properties
that have a value type, an initial value, and a defined inheritance behaviour. This
specification also provides an additional javascript-mediated means via which custom
properties can modify the computed value of native properties.

This specification is complementary to [[css-paint-api]] and [[css-layout-api]], which
allow custom properties to directly impact paint and layout behaviours respectively.
Accordingly, it is recommended not to use the computed value modification facilities of this
specification directly for layout, but only to impact cascading in a non-native manner.

Registering custom properties {#registering-custom-properties}
==============================================================

<pre class='idl'>
dictionary PropertyDescriptor {
  DOMString name;
  DOMString syntax;
  boolean   inherits;
  DOMString initialValue;
};

partial interface CSS {
  void registerProperty(PropertyDescriptor descriptor);
  void unregisterProperty(DOMString name);
};
</pre>

The {{PropertyDescriptor}} dictionary {#the-propertydescriptor-dictionary}
--------------------------------------------------------------------------

A <dfn>PropertyDescriptor</dfn> dictionary represents author-specified configuration
options for a custom property. {{PropertyDescriptor}} dictionaries contain the
following members:

:   <dfn dict-member for=PropertyDescriptor>name</dfn>
::  The name of the custom property being defined.

:   <dfn dict-member for=PropertyDescriptor>syntax</dfn>
::  A string representing how this custom property is parsed.

:   <dfn dict-member for=PropertyDescriptor>inherits</dfn>
::  True if this custom property should inherit down the DOM tree; False otherwise.

:   <dfn dict-member for=PropertyDescriptor>initialValue</dfn>
::  The initial value of this custom property.

The {{registerProperty()}} function {#the-registerproperty-function}
--------------------------------------------------------------------

The <dfn method for=CSS>registerProperty(PropertyDescriptor descriptor)</dfn> method
registers a custom property according the to configuration options provided in
<code>descriptor</code>.

Attempting to register properties with a {{PropertyDescriptor/name}} that doesn't
correspond to the <<custom-property-name>> production must cause {{registerProperty()}}
to throw a {{SyntaxError}}.

The list of types supported in the {{PropertyDescriptor/syntax}} member are listed
in <a section href="#supported-syntax-strings"></a>. Currently, only simple
type references are supported. Attempting to register properties with a
{{PropertyDescriptor/syntax}} that is not supported must cause {{registerProperty()}}
to throw a {{SyntaxError}}.

Note: for example, the syntax string could be "&lt;length&gt;" or "&lt;number&gt;".

Note: in future levels we anticipate supporting more sophisticated parse strings, e.g.
"&lt;length&gt; || &lt;number&gt;"

Attempting to call {{registerProperty()}} with an {{PropertyDescriptor/initialValue}} that is
not parseable using the provided {{PropertyDescriptor/syntax}} must cause it to
throw a {{SyntaxError}}.

When a custom property is registered with a given type, the process via which specified
values for that property are turned into computed values is defined
fully by the type selected, as described in
<a section href="#calculation-of-computed-values"></a>.

Note: As defined by [[css3-animations]] and [][css3-transitions]], it is possible to
specify animations and transitions that reference custom properties.

When referenced by animations and transitions, custom properties will interpolate
in a manner defined by their types.
If the start and end of an interpolation have matching types, then they
will interpolate as specified in [[!css3-animations]] or the corresponding property.
Otherwise, the interpolation falls back to the default 50% flip described in
[[!css3-animations]].

If {{registerProperty()}} is called with a descriptor name that matches an already registered property,
then an {{InvalidModificationError}} is thrown and the re-registration fails.

Properties can be unregistered using
<dfn method for=CSS>unregisterProperty(DOMString name)</dfn>.
If this function is called with a name that doesn't match an existing property
then a {{NotFoundError}} is thrown.

Successful calls to both {{registerProperty()}} and {{unregisterProperty()}}
trigger a reparse of all parsed CSS.

Supported syntax strings {#supported-syntax-strings}
----------------------------------------------------

The following syntax strings are supported:

:   "&lt;length>"
::  Any valid <<length>> value
:   "&lt;number>"
::  <<number>> values
:   "&lt;percentage>"
::  Any valid <<percentage>> value
:   "&lt;custom-ident>"
::  Any valid <<custom-ident>> value
:   Any string, the contents of which matches the <<ident>> production
::  That string
:   "&lt;[property-name]>", Where [property-name] is any existing CSS property
    name
::  Any value that parses as a value of the specified property.
:   Any combination of the preceding, separated by '|'
::  Any value that matches one of the items in the combination, matched in specified order.
:   "*"
::  Any valid token stream

Regardless of the syntax specified, all custom properties will accept
<a>CSS-wide keywords</a> as well as ''revert'', and process these values
appropriately.

Note: This does not apply to the {{PropertyDescriptor/initialValue}} member
of the {{PropertyDescriptor}} dictionary.

<div class='example'>
For example, the following are all valid syntax strings.

:   <code>"&lt;length>"</code>
::  accepts length values
:   <code>"&lt;length> | &lt;percentage>"</code>
::  accepts lengths, or percentages, or length calc expressions, but not
    calc expressions containing a combination of length and percent values.
:   <code>"big | bigger | BIGGER"</code>
::  accepts the string "big", or the string "bigger", or the string "BIGGER".
:   <code>"&lt;background-color>"</code>
::  accepts any value that would be accepted by the 'background-color' property
    (e.g. "#F00", "red", "rgba(10, 10, 10, 0.5)", etc.)

</div>

Calculation of Computed values {#calculation-of-computed-values}
----------------------------------------------------------------

The syntax of a custom property fully determines how computed values are
generated from specified values for that property.

The <a>CSS-wide keywords</a> and ''revert'' generate computed values as
described in [[!css3-values]] and [[!css-cascade-4]] respectively. Otherwise:

For &lt;length> values, the computed value is the absolute length expressed in pixels.

For &lt;number>, &lt;percentage>, &lt;custom-ident>, string or "*" values, the
computed value is identical to the specified value.

For values with a syntax that references a CSS property, the computed value
is defined by that property.

For values specified by a syntax string that include "|" clauses, the computed
value is given by applying the calculation rules for the first clause that
matches to the specified value.

The apply hook {#the-apply-hook}
================================

<pre class='idl'>

interface ElementProxy {
  // includes affordances for writing to computed values, but only
  // those in outputProperties. Also for reading computed style
  // values, but only those in inputProperties..
};

callback ApplyCallback = void (ElementProxy element);

dictionary ApplyDescriptor {
  ApplyCallback applyHook;
  sequence&lt;DOMString&gt; inputProperties;
  sequence&lt;DOMString&gt; outputProperties;
};

partial interface Context {
  long registerApplyHook(ApplyDescriptor apply);
  void unregisterApplyHook(long hookID);
};
</pre>


:   <dfn dict-member for=ApplyDescriptor>inputProperties</dfn>
::  The apply function is only called for elements or
    pseudoelements on which the listed properties all have non-initial values.

Issue(4): It should it be possible to access properties on the parent.

Issue(2): Should this be available only if explicitly requested in inputProperties?

:   <dfn dict-member for=ApplyDescriptor>outputProperties</dfn>
::  This value defines the properties for which the apply function can modify the used
    value.

If a {{registerApplyHook()}} call is made with a list of outputProperties that contains
properties that have already been registered for output, then an exception is thrown and
the call fails.

Issue(49): This is too inflexible. There’s a strong use case around writing to the
same native property for different elements. Maybe throw exception to
window.onError in this case?

Each time style is recomputed for an Element, each registered {{ApplyDescriptor/applyHook}}
for which any of the matching {{ApplyDescriptor/inputProperties}} changes as a result of
that recomputation is invoked. This invocation happens after any transitions or animations
registered on the Element have finished applying.

Note: apply hooks are called after transitions/animations so that custom properties
      can be transitioned and still have their effect apply correctly.

This invocation takes place in an <a>isolated worker</a>.


Examples {#examples}
====================

Example 1: Polyfill scale, translate, rotate {#example-1}
---------------------------------------------------------

This approach prohibits the direct use of the transform property.

<pre class='lang-markup'>
&lt;script&gt;
["--scale-x", "--scale-y"].forEach(function(prop){
document.registerProperty({
    name: prop,
    inherits: false,
    initial: 1,
    syntax: "&lt;number&gt;"
    });
});

["--translate-x", "--translate-y"].forEach(function(name) {
  document.registerProperty({
    name: name,
    initial: "0px",
    inherits: false,
    syntax: "&lt;length&gt;"
  });
});

document.registerProperty({
  name: "--rotate",
  initial: "0deg",
  syntax: "&lt;angle&gt;"
  inherits: false
});
&lt;/script&gt;
&lt;style&gt;

#myElement {
    --translate-x: 5px;
    --translate-y: 10px;
    --rotate: 10deg;
    --scale-x: 25;
    --scale-y: 25;
}

.foobar {
    --rotate: 20deg;
}
&lt;/style&gt;

&lt;script&gt;
this.registerApplyHook({
    apply: function(el) {
      el.outputStyle.transform = 'translate(' + el.style.get('--translate-x') + ', ' + el.style.get('--translate-y') +
                                   ') rotate(' + el.style.get('--rotate') +
                                   ') scale(' + el.style.get('--scale-x') + ', ' + el.style.get('--scale-y') + ')' +
                                   el.style.get('transform');
    },
    inputProperties: ["--translate-*", "--scale-*", "--rotate", "transform"],
    outputProperties: ["transform"]
});
&lt;/script&gt;
</pre>
