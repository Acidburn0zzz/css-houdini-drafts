<pre class='metadata'>
Title:  CSS Layout API Level 1
Status: DREAM
Group: houdini
ED: https://drafts.css-houdini.org/css-layout-api-1/
Shortname: css-layout-api
Level: 1
Abstract:
Editor: Greg Whitworth, gwhit@microsoft.com 
Editor: Ian Kilpatrick, ikilpatrick@chromium.org
Editor: Tab Atkins, jackalmage@gmail.com
Editor: Shane Stephens, shanestephens@google.com
Editor: Robert O'Callahan, robert@ocallahan.org
Editor: Rossen Atanassov, rossen.atanassov@microsoft.com
Ignored Terms: LayoutWorklet
Ignored Terms: create a workletglobalscope
</pre>

<style>
/* Put nice boxes around each algorithm. */
[data-algorithm]:not(.heading) {
    padding: .5em;
    border: thin solid #ddd; border-radius: .5em;
    margin: .5em calc(-0.5em - 1px);
}
[data-algorithm]:not(.heading) > :first-child {
    margin-top: 0;
}
[data-algorithm]:not(.heading) > :last-child {
    margin-bottom: 0;
}
</style>

<pre class="link-defaults">
spec:css-break-3; type:dfn; text:fragment
spec:css-display-3; type:dfn; text:box
spec:css-display-3; type:value; for:display; text:none
spec:css-display-3; type:value; for:<display-inside>; text:grid
spec:dom; type:dfn; for:/; text:element
spec:infra; type:dfn; text:list
</pre>

<pre class="anchors">
urlPrefix: https://heycam.github.io/webidl/; type: dfn;
    text: InvalidModificationError
    urlPrefix: #dfn-;
        url: throw; text: thrown
    urlPrefix: #idl-;
        text: boolean
        text: DOMException
    url: es-type-mapping; text: converting
    url: es-invoking-callback-functions; text: Invoke
urlPrefix: https://tc39.github.io/ecma262/#sec-; type: dfn;
    text: constructor
    text: Construct
    text: IsArray
    text: IsCallable
    text: IsConstructor
    text: HasProperty
    url: ecmascript-data-types-and-values; text: type
    url: get-o-p; text: Get
    url: generatorfunction; text: generator function
    url: terms-and-definitions-function; text: function
    urlPrefix: native-error-types-used-in-this-standard-
        text: TypeError
</pre>

Introduction {#intro}
=====================

<em>This section is not normative.</em>

The layout stage of CSS is responsible for generating and positioning <a>fragments</a> from the
<a>box tree</a>.

This specification describes an API which allows developers to layout a <a>box</a> in response to
computed style and <a>box</a> tree changes.

Layout API Containers {#layout-api-containers}
==============================================

<pre class="propdef">
    Name: display
    New values: layout(<<ident>>) | inline-layout(<<ident>>)
</pre>

<dl dfn-for="display" dfn-type=value>
    <dt><dfn>layout()</dfn>
    <dd>
        This value causes an element to generate a block-level <a>layout API container</a> box.
    <dt><dfn>inline-layout()</dfn>
    <dd>
        This value causes an element to generate an inline-level <a>layout API container</a> box.
</dl>

A <dfn>layout API container</dfn> is the box generated by an element with a computed 'display' of
''layout()'' or ''inline-layout()''.

A <a>layout API container</a> establishes a new <dfn>layout API formatting context</dfn> for its
contents. This is the same as establishing a block formatting context, except that the layout
provided by the author is used instead of the block layout.
For example, floats do not intrude into the layout API container, and the layout API container's
margins do not collapse with the margins of its contents.

<a>Layout API containers</a> form a containing block for their contents
<a href="https://www.w3.org/TR/CSS2/visudet.html#containing-block-details">exactly like block
containers do</a>. [[!CSS21]]

Note: In a future level of the specification there may be a way to override the containing block
    behaviour.

The 'overflow' property applies to <a>layout API containers</a>. This is discussed (TODO: writing
about scrollbars).

As the layout is entirely up to the author, properties which are used in other layout modes (e.g.
flex, block) may not apply. For example an author may not call respect the 'width' or 'height'
properties.

If an element's specified 'display' is ''inline-layout()'', then its 'display' property computes to
''layout()'' in certain circumstances: the table in <a
href="https://www.w3.org/TR/CSS2/visuren.html#dis-pos-flo">CSS 2.1 Section 9.7</a> is amended to
contain an additional row, with ''inline-layout()'' in the "Specified Value" column and ''layout()''
in the "Computed Value" column.

A <a>layout API container</a> has a <dfn>layout instance</dfn>, initially this is set to null. This
is an instance of the author defined layout class (see [[#registering-layout]]). If the <a>box</a>'s
<a>computed value</a> of 'display' changes, this must be reset to null.

Issue: Having the layout instance on the box is wrong, should really be a map on the layout worklet
    global scope.

Layout API Container Painting {#painting}
-----------------------------------------

<a>Layout API Container</a> children paint exactly the same as inline blocks [[!CSS21]], except that
the order in which they are returned from the layout method (via
{{FragmentResultOptions/childFragments}}) is used in place of raw document order, and 'z-index'
values other than ''z-index/auto'' create a stacking context even if 'position' is ''static''.

Layout API Model and Terminology {#layout-api-model-and-terminology}
====================================================================

This section gives an overview of the Layout API given to authors.

The <dfn>current layout</dfn> is the layout algorithm for the <a>box</a> we are currently performing
layout for.

The <dfn>parent layout</dfn> is the layout algorithm for the <a>box</a>'s direct parent, (the layout
algorithm which is requesting the <a>current layout</a> to be performed).

A <dfn>child layout</dfn> is the layout algorithm for a {{LayoutChild}} of the <a>current layout</a>.

Layout Children {#layout-children}
----------------------------------

<pre class='idl'>
[Exposed=LayoutWorklet]
interface LayoutChild {
    readonly attribute StylePropertyMapReadOnly styleMap;

    FragmentRequest layoutNextFragment(ConstraintSpace space, ChildBreakToken breakToken);
};

[Exposed=LayoutWorklet]
interface InlineLayoutChild : LayoutChild {
};

[Exposed=LayoutWorklet]
interface BoxLayoutChild : LayoutChild {
};
</pre>

A {{LayoutChild}} represents either a CSS generated <a>box</a> or a sequence of non-<a>atomic inline
boxes</a> before layout has occurred. (The box or boxes will all have a computed value of 'display'
that is not ''none'').

The {{LayoutChild}} does not contain any layout information itself (like inline or block size) but
can be used to generate {{Fragment}}s which do contain layout information.

An author cannot construct a {{LayoutChild}} with this API, this happens at a separate stage of the
rendering engine (post style resolution).

A {{InlineLayoutChild}} represents a sequence of non-<a>atomic inlines</a>. It does not have a
single computed style associated with it as it may contain multiple inline boxes inside it
with different computed style.

<div class="note">
    Note: As an example the following would be placed into a single {{InlineLayoutChild}}:
    <pre class="lang-html">
        This is a next node, &lt;span>with some additional styling,
        that may&lt;/span> break over&lt;br>multiple lines.
    </pre>
</div>

Multiple non-<a>atomic inlines</a> are placed within the same {{InlineLayoutChild}} to allow
rendering engines to perform text shaping across element boundaries.

<div class="note">
    Note: As an example the following should produce one {{Fragment}} but is from
    three non-<a>atomic inlines</a>:
    <pre class="lang-html">
        &#x639;&lt;span style="color: blue">&#x639;&lt;/span>&#x639;
    </pre>
</div>

Note: In a future level of the specification there may be a way to query the computed style
      of ranges inside a {{InlineLayoutChild}}.

A {{BoxLayoutChild}} represents a single <a>box</a>. It does have an associated computed style which
can be accessed by {{LayoutChild/styleMap}}. The {{LayoutChild/styleMap}} will only contain
properties which are listed in the child input properties array.

A {{BoxLayoutChild}} could be generated by:

 - An <a>element</a>.

 - A <a>::before</a> or <a>::after</a> pseudo-element.

    Note: Other pseudo-elements such as <a>::first-letter</a> or <a>::first-line</a> do not generate
        a {{BoxLayoutChild}} for layout purposes. They are additional styling information for a text
        node.

 - An <a>anonymous box</a>. For example an anonymous box may be inserted as a result of:

    - A text node which has undergone <a>blockification</a>. (Or more generally a
        {{InlineLayoutChild}} which has undergone <a>blockification</a>).

    - An element with ''display: table-cell'' which doesn't have a parent with ''display: table''.

 - An <a>atomic inline</a>.

<div class="note">
    Note: As an example the following would be placed into three {{BoxLayoutChild}}ren:
    <pre class="lang-html">
        &lt;style>
          #box::before { content: 'hello!'; }
        &lt;/style>
        <!-- A ::before pseudo-element is inserted here. -->
        &lt;div id="box">A block level box with text.&lt;/div>
        &lt;img src="..." />
    </pre>
</div>

An array of {{LayoutChild}}ren is passed into the layout method which represents the children of the
current box which is being laid out.

To perform layout on a box the author can invoke the {{LayoutChild/layoutNextFragment()}} method.
This will produce a {{Fragment}} which contains layout information.

The {{LayoutChild/layoutNextFragment()}} method may be invoked multiple times with different
arguments to query the {{LayoutChild}} for different layout information.

Layout Fragments {#layout-fragments}
------------------------------------

<pre class='idl'>
[Exposed=LayoutWorklet]
interface Fragment {
    readonly attribute double inlineSize;
    readonly attribute double blockSize;

    attribute double inlineOffset;
    attribute double blockOffset;

    readonly attribute ChildBreakToken? breakToken;

    readonly attribute double alignmentBaseline;
};
</pre>

A {{Fragment}} represents a CSS <a>fragment</a> of a {{LayoutChild}} after layout has occurred on
that child. This is produced by the {{LayoutChild/layoutNextFragment()}} method.

The {{Fragment}} has {{Fragment/inlineSize}} and {{Fragment/blockSize}} attributes, which are set by
the respective child's layout algorithm. They cannot be changed. If the <a>current layout</a>
requires a different {{Fragment/inlineSize}} or {{Fragment/blockSize}} the author must perform
{{LayoutChild/layoutNextFragment()}} again with different arguments in order to get different
results.

The author inside the current layout can position a resulting {{Fragment}} by setting its
{{Fragment/inlineOffset}} and {{Fragment/blockOffset}} attributes. If not set by the author they
default to zero.

<div class="example">
The layout algorithm performs a block-like layout (positioning fragments sequentially in the block
direction), while centering its children in the inline direction.

<pre class="lang-javascript">
registerLayout('block-like', class extends Layout {
    static blockifyChildren = true;
    static inputProperties = super.inputProperties;

    *layout(space, children, styleMap) {
        const inlineSize = resolveInlineSize(space, styleMap);

        const bordersAndPadding = resolveBordersAndPadding(constraintSpace, styleMap);
        const scrollbarSize = resolveScrollbarSize(constraintSpace, styleMap);
        const availableInlineSize = inlineSize -
                                    bordersAndPadding.inlineStart -
                                    bordersAndPadding.inlineEnd -
                                    scrollbarSize.inline;

        const availableBlockSize = resolveBlockSize(constraintSpace, styleMap) -
                                   bordersAndPadding.blockStart -
                                   bordersAndPadding.blockEnd -
                                   scrollbarSize.block;

        const childFragments = [];
        const childConstraintSpace = new ConstraintSpace({
            inlineSize: availableInlineSize,
            blockSize: availableBlockSize,
        });

        let maxChildInlineSize = 0;
        let blockOffset = bordersAndPadding.blockStart;

        for (let child of children) {
            const fragment = yield child.layoutNextFragment(childConstraintSpace);

            // Position the fragment in a block like manner, centering it in the
            // inline direction.
            fragment.blockOffset = blockOffset;
            fragment.inlineOffset = Math.max(
                bordersAndPadding.inlineStart,
                (availableInlineSize - fragment.inlineSize) / 2);

            maxChildInlineSize =
                Math.max(maxChildInlineSize, childFragments.inlineSize);
            blockOffset += fragment.blockSize;
        }

        const contentSize = blockOffset + bordersAndPadding.blockEnd;
        const blockSize = resolveBlockSize(
            constraintSpace, styleMap, contentSize);

        return {
            inlineSize: inlineSize,
            blockSize: blockSize,
            childFragments: childFragments,
        };
    }
});
</pre>
</div>

The {{Fragment}}'s {{Fragment/breakToken}} specifies where the {{LayoutChild}} last fragmented. If
the {{Fragment/breakToken}} is null the {{LayoutChild}} wont produce any more {{Fragment}}s for that
token chain. The {{Fragment/breakToken}} can be passed to the {{LayoutChild/layoutNextFragment()}}
function to produce the next {{Fragment}} for a particular child. The {{Fragment/breakToken}} cannot
be changed.
If the <a>current layout</a> requires a different {{Fragment/breakToken}} the author must perform
{{LayoutChild/layoutNextFragment()}} again with different arguments.

The {{Fragment}}'s {{Fragment/alignmentBaseline}} attribute specify where the alignment baseline is
positioned relative to the block start of the fragment. It cannot be changed.

Note: In a future level of the specification there may be a way to query for additional baseline
      information, for example where the alphabetic or center baseline is positioned.

Constraint Spaces {#constraint-spaces}
--------------------------------------

<pre class='idl'>
[Constructor(optional ConstraintSpaceOptions options),Exposed=LayoutWorklet]
interface ConstraintSpace {
    readonly attribute double inlineSize;
    readonly attribute double blockSize;

    readonly attribute boolean inlineSizeFixed;
    readonly attribute boolean blockSizeFixed;

    readonly attribute double percentageInlineSize;
    readonly attribute double percentageBlockSize;

    readonly attribute BlockFragmentationType blockFragmentationType;
};

dictionary ConstraintSpaceOptions {
    double inlineSize = Infinity;
    double blockSize = Infinity;

    boolean inlineSizeFixed = false;
    boolean blockSizeFixed = false;

    double? percentageInlineSize = null;
    double? percentageBlockSize = null;

    BlockFragmentationType blockFragmentationType = "none";
};

enum BlockFragmentationType { "none", "page", "column", "region" };
</pre>

A {{ConstraintSpace}} is passed into the layout method which represents the available space for the
<a>current layout</a> to perform layout inside. It is also used to pass information about the
available space into a <a>child layout</a>.

The {{ConstraintSpace}} has {{ConstraintSpace/inlineSize}} and {{ConstraintSpace/blockSize}}
attributes. This represents the <a>available space</a> for a {{Fragment}} which the layout should
respect.

Note: Some layouts may need to produce a {{Fragment}} which exceed this size. For example a
    <a>replaced element</a>. The <a>parent layout</a> should expect this to occur and deal with it
    appropriately.

A <a>parent layout</a> may require the <a>current layout</a> to be exactly a particular size. If
the {{ConstraintSpace/inlineSizeFixed}} or {{ConstraintSpace/blockSizeFixed}} are true the
<a>current layout</a> should produce a {{Fragment}} with a fixed size in the appropriate direction.

<div class="example">
The layout algorithm performs a flexbox-like distribution of spare space in the inline direction. It
creates child constraint spaces which specify that a child should be a fixed inline size.

<pre class="lang-javascript">
registerLayout('flex-distribution-like', class {
    *layout(space, children, styleMap, breakToken) {
        const inlineSize = resolveInlineSize(space, styleMap);

        const bordersAndPadding = resolveBordersAndPadding(constraintSpace, styleMap);
        const scrollbarSize = resolveScrollbarSize(constraintSpace, styleMap);
        const availableInlineSize = inlineSize -
                                    bordersAndPadding.inlineStart -
                                    bordersAndPadding.inlineEnd -
                                    scrollbarSize.inline;

        const availableBlockSize = resolveBlockSize(constraintSpace, styleMap) -
                                   bordersAndPadding.blockStart -
                                   bordersAndPadding.blockEnd -
                                   scrollbarSize.block;

        const unconstrainedSizes = [];
        const childConstraintSpace = new ConstraintSpace({
            inlineSize: availableInlineSize,
            blockSize: availableBlockSize,
        });
        let totalSize = 0;

        // Calculate the unconstrained size for each child.
        for (let child of children) {
            const fragment = yield child.layoutNextFragment(childConstraintSpace);
            unconstrainedSizes.push(fragment.inlineSize);
            totalSize += fragment.inlineSize;
        }

        // Distribute spare space between children.
        const remainingSpace = Math.max(0, inlineSize - totalSize);
        const extraSpace = remainingSpace / children.length;
        const childFragments = [];
        let inlineOffset = 0;
        let maxChildBlockSize = 0;
        for (let i = 0; i < children.length; i++) {
            let fragment = yield child.layoutNextFragment(new ConstraintSpace({
                inlineSize: unconstrainedSizes[i] + extraSpace,
                inlineSizeFixed: true,
                blockSize: availableBlockSize
            }));

            fragment.inlineOffset = inlineOffset;
            inlineOffset += fragment.inlineSize;

            maxChildBlockSize = Math.max(maxChildBlockSize, fragment.blockSize);

            childFragments.push(fragment);
        }

        // Resolve our block size.
        const blockSize = resolveBlockSize(constraintSpace, styleMap, maxChildBlockSize);

        return {
            inlineSize: inlineSize,
            blockSize: blockSize,
            childFragments: childFragments,
        };
    }
});
</pre>
</div>

The {{ConstraintSpace}} has {{ConstraintSpace/percentageInlineSize}} and
{{ConstraintSpace/percentageBlockSize}} attributes. These represent the size that a layout
percentages should be resolved against while performing layout.

The {{ConstraintSpace}} has a {{ConstraintSpace/blockFragmentationType}} attribute. The <a>current
layout</a> should produce a {{Fragment}} which fragments at the {{ConstraintSpace/blockSize}} if
possible. 

The <a>current layout</a> may choose not to fragment a {{LayoutChild}} based on the
{{ConstraintSpace/blockFragmentationType}}, for example if the child has a property like
''break-inside: avoid-page;''.

Breaking and Fragmentation {#breaking-and-fragmentation}
--------------------------------------------------------

<pre class="idl">
[Exposed=LayoutWorklet]
interface ChildBreakToken {
    readonly attribute BreakType breakType;
    readonly attribute LayoutChild child;
};

[Exposed=LayoutWorklet]
interface BreakToken {
    readonly attribute sequence&lt;ChildBreakToken> childBreakTokens;
    readonly attribute any data;
};

dictionary BreakTokenOptions {
    sequence&lt;ChildBreakToken> childBreakTokens;
    any data = null;
};

enum BreakType { "none", "inline", "inline-hyphen", "column", "page", "region" };
</pre>

Issue: Fill out other inline type break types.

A {{LayoutChild}} can produce multiple {{Fragment}}s. A {{BoxLayoutChild}} may fragment in the block
direction if a {{ConstraintSpace/blockFragmentationType}} is not none. A {{InlineLayoutChild}} may
fragment in the inline direction.

A subsequent {{Fragment}} is produced by using the previous {{Fragment}}'s {{Fragment/breakToken}}.
This tells the <a>child layout</a> to produce a {{Fragment}} starting at the point encoded in the
{{ChildBreakToken}}.

Issue: Explain resuming the author defined layout.

<div class="example">
This example shows a simple inline layout which places child fragments in the inline direction. It
places each of its on a line, aligning their baselines.

This example also demonstrates using the previous {{Fragment/breakToken}} of a {{Fragment}} to
produce the next fragment for the {{LayoutChild}}.

It also demonstrates using the {{BreakToken}} to respect the {{ConstraintSpace}}'s
{{ConstraintSpace/blockFragmentationType}}, it resumes it layout from the previous {{BreakToken}}.
It returns a {{FragmentResultOptions}} with a {{FragmentResultOptions/breakToken}} which is used to
resume the layout.

<pre class="lang-javascript">
registerLayout('basic-inline', class extends Layout {
    static inputProperties = super.inputProperties;

    *layout(constraintSpace, children, styleMap, breakToken) {
        // Resolve our inline size.
        const inlineSize = resolveInlineSize(constraintSpace, styleMap);

        // Determine our (inner) available size.
        const bordersAndPadding =
            resolveBordersAndPadding(constraintSpace, styleMap);
        const scrollbarSize = resolveScrollbarSize(constraintSpace, styleMap);
        const availableInlineSize = inlineSize -
                                    bordersAndPadding.inlineStart -
                                    bordersAndPadding.inlineEnd -
                                    scrollbarSize.inline;

        const availableBlockSize = resolveBlockSize(constraintSpace, styleMap) -
                                   bordersAndPadding.blockStart -
                                   bordersAndPadding.blockEnd -
                                   scrollbarSize.block;

        const childFragments = [];

        let currentLine = [];
        let usedInlineSize = 0;
        let maxBaseline = 0;

        let lineOffset = 0;
        let maxLineBlockSize = 0;

        // Just a small little function which will update the above variables.
        const nextLine = function() {
            currentLine = [];
            usedInlineSize = 0;
            maxBaseline = 0;

            lineOffset += maxLineBlockSize;
            maxLineBlockSize = 0;
        }

        let childBreakToken = null;
        if (breakToken) {
            childBreakToken = breakToken.childBreakTokens[0];

            // Remove all the children we have already produced fragments for.
            children.splice(0, children.indexOf(childBreakToken.child));
        }

        let child = children.shift();
        while (child) {
            // Make sure we actually have space on the current line.
            if (usedInlineSize > availableInlineSize) {
                nextLine();
            }

            // The constraint space here will have the inline size of the
            // remaining space on the line.
            const remainingInlineSize = availableInlineSize - usedInlineSize;
            const constraintSpace = new ConstraintSpace({
                inlineSize: availableInlineSize - usedInlineSize,
                blockSize: availableBlockSize,
                percentageInlineSize: availableInlineSize,
            });

            const fragment = yield child.layoutNextFragment(constraintSpace,
                                                            childBreakToken);
            childFragments.push(fragment);

            // Check if there is still space on the current line.
            if (fragment.inlineSize > remainingInlineSize) {
                nextLine();

                // Check if we have gone over the block fragmentation limit.
                if (constraintSpace.blockFragmentationType != 'none' &&
                    lineOffset > constraintSpace.blockSize) {
                    break;
                }
            }

            // Insert fragment on the current line.
            currentLine.push(fragment);
            fragment.inlineOffset = usedInlineSize;

            if (fragment.alignmentBaseline > maxBaseline) {
                maxBaseline = fragment.alignmentBaseline;
            }

            // Go through each of the fragments on the line and update their
            // block offsets.
            for (let fragmentOnLine of currentLine) {
                fragmentOnLine.blockOffset = lineOffset +
                    maxBaseline - fragmentOnLine.alignmentBaseline;

                const lineBlockSize =
                    fragmentOnLine.blockOffset + fragmentOnLine.blockSize;
                if (maxLineBlockSize < lineBlockSize) {
                    maxLineBlockSize = lineBlockSize;
                }
            }

            if (fragment.breakToken) {
                childBreakToken = fragment.breakToken;
            } else {
                // If a fragment doesn't have a break token, we move onto the
                // next child.
                child = children.shift();
                childBreakToken = null;
            }
        }

        // Determine our block size.
        nextLine();
        const contentSize = lineOffset +
                                  bordersAndPadding.blockStart +
                                  bordersAndPadding.blockEnd;
        const blockSize = resolveBlockSize(constraintSpace,
                                           styleMap,
                                           contentSize);

        // Return our fragment.
        const result = {
            inlineSize: inlineSize,
            blockSize: blockSize,
            childFragments: childFragments,
        }

        if (childBreakToken) {
            result.breakToken = {
                childBreakTokens: [childBreakToken],
            };
        }

        return result;
    }
});
</pre>
</div>

Utility Functions {#utility-functions}
--------------------------------------

<pre class='idl'>
[Exposed=LayoutWorklet]
interface LayoutStrut {
  readonly attribute double inlineStart;
  readonly attribute double inlineEnd;

  readonly attribute double blockStart;
  readonly attribute double blockEnd;
};

[Exposed=LayoutWorklet]
interface LayoutSize {
  readonly attribute double inline;
  readonly attribute double block;
};

partial interface LayoutWorkletGlobalScope {
    double resolveInlineSize(ConstraintSpace constraintSpace,
                             StylePropertyMapReadOnly styleMap);

    double resolveBlockSize(ConstraintSpace constraintSpace,
                            StylePropertyMapReadOnly styleMap,
                            optional double contentSize);

    LayoutStrut resolveBordersAndPadding(ConstraintSpace constraintSpace,
                                         StylePropertyMapReadOnly styleMap);

    LayoutSize resolveScrollbarSize(ConstraintSpace constraintSpace,
                                    StylePropertyMapReadOnly styleMap);
};

[Exposed=LayoutWorklet]
interface Layout {
    readonly attribute sequence&lt;DOMString> inputProperties;
    readonly attribute sequence&lt;DOMString> childInputProperties;
};
</pre>

Issue: Specify the behaviour of these functions.

Layout {#layout}
================

This section describes how the CSS Layout API interacts with the user agent's layout engine.

Layout Invalidation {#layout-invalidation}
------------------------------------------

A <a>document</a> has an associated <dfn>layout name to input properties map</dfn> and a <dfn>layout
name to child input properties map</dfn>. Initially these maps are empty and are populated when
{{registerLayout(name, layoutCtor)}} is called.

Each <a>box</a> has an associated <dfn>layout valid flag</dfn>. It may be either
<dfn>layout-valid</dfn> or <dfn>layout-invalid</dfn>. It is initially set to <a>layout-invalid</a>.

Issue: The above flag is too restrictive on user agents, change.

When the computed style for a |box| changes, the user agent must run the following steps:
    1. Let |layoutFunction| be the <<layout()>> or <<inline-layout()>> function of the 'display'
        property on the computed style for the |box| if it exists. If it is a different type of
        value (e.g.  ''grid'') then abort all these steps.

    2. Let |name| be the first argument of the |layoutFunction|.

    3. Let |inputProperties| be the result of looking up |name| on <a>layout name to input
        properties map</a>.

    4. Let |childInputProperties| be the result of looking up |name| on <a>layout name to child
        input properties map</a>.

    5. For each |property| in |inputProperties|, if the |property|'s <a>computed value</a> has
        changed, set the <a>layout valid flag</a> on the <a>box</a> to <a>layout-invalid</a>.

    6. For each |property| in |childInputProperties|, if the |property|'s <a>computed value</a> has
        changed, set the <a>layout valid flag</a> on the <a>box</a> to <a>layout-invalid</a>.

When a child <a>box</a> represented by a {{BoxLayoutChild}} is added or removed from the <a>box
tree</a> or has its layout invalidated (from a computed style change). Set the <a>layout valid
flag</a> on the current <a>box</a> to <a>layout-invalid</a>.

When a child non-<a>atomic inline</a> represented by a {{InlineLayoutChild}} is added or removed
from the <a>box tree</a> or has its layout invalidated (from a computed style change, or if its text
has changed). Set the <a>layout valid flag</a> on the current <a>box</a> to <a>layout-invalid</a>.

Note: This only describes layout invalidation as it relates to the CSS Layout API. All
    <a>boxes</a> conceptually have a <a>layout valid flag</a> and these changes are propagated
    through the <a>box tree</a>.

Concepts {#concepts}
--------------------

A <dfn>layout definition</dfn> is a <a>struct</a> which describes the information needed by the
{{LayoutWorkletGlobalScope}} about hte author defined layout (which can be referenced by the
<<layout()>> function). It consists of:

 - <dfn for="layout definition">class constructor</dfn> which is the class <a>constructor</a>.

 - <dfn for="layout definition">layout generator function</dfn> which is the layout <a>generator
     function</a> callback.

 - <dfn for="layout definition">content size generator function</dfn> which is the content size
     <a>generator function</a> callback.

 - <dfn for="layout definition">constructor valid flag</dfn>.

 - <dfn for="layout definition">input properties</dfn> which is a <a>list</a> of
     <code>DOMStrings</code>

 - <dfn for="layout definition">child input properties</dfn> which is a <a>list</a> of
     <code>DOMStrings</code>.

 - <dfn for="layout definition">child display</dfn> a {{ChildDisplayType}}.

A <dfn>document layout definition</dfn> is a <a>struct</a> which describes the information needed by
the <a>document</a> about the author defined layout (which can be referenced by the <<layout()>>
function). It consists of:

 - <dfn for="document layout definition">input properties</dfn> which is a <a>list</a> of
     <code>DOMStrings</code>

 - <dfn for="document layout definition">child input properties</dfn> which is a <a>list</a> of
     <code>DOMStrings</code>.

 - <dfn for="document layout definition">child display</dfn> a {{ChildDisplayType}}.

Layout Worklet {#layout-worklet}
--------------------------------

The {{layoutWorklet}} attribute allows access to the {{Worklet}} responsible for all the classes
which are related to layout.

The {{layoutWorklet}}'s <a>worklet global scope type</a> is {{LayoutWorkletGlobalScope}}.

<pre class='idl'>
partial interface CSS {
    [SameObject] readonly attribute Worklet layoutWorklet;
};
</pre>

The {{LayoutWorkletGlobalScope}} is the global execution context of the {{layoutWorklet}}.

<pre class='idl'>
[Global=(Worklet,LayoutWorklet),Exposed=LayoutWorklet]
interface LayoutWorkletGlobalScope : WorkletGlobalScope {
    void registerLayout(DOMString name, VoidFunction layoutCtor);
};
</pre>

Registering A Layout {#registering-layout}
------------------------------------------

<pre class='idl'>
[Exposed=LayoutWorklet]
enum ChildDisplayType {
    "block",
    "normal",
};
</pre>

Issue: "normal" is a bad name?

The <a>document</a> has a <a>map</a> of <dfn>document layout definitions</dfn>. Initially this map
is empty; it is populated when {{registerLayout(name, layoutCtor)}} is called.

The {{LayoutWorkletGlobalScope}} has a <a>map</a> of <dfn>layout definitions</dfn>. Initially this
map is empty; it is populated when {{registerLayout(name, layoutCtor)}} is called.

The {{LayoutWorkletGlobalScope}} has a <a>map</a> of <dfn>layout class instances</dfn>. Initially
this map is empty; it is populated when {{registerLayout(name, layoutCtor)}} is called.

<div algorithm>
When the <dfn method for=LayoutWorkletGlobalScope>registerLayout(|name|, |layoutCtor|)</dfn> method
is called, the user agent <em>must</em> run the following steps:
    1. If the |name| is an empty string, <a>throw</a> a <a>TypeError</a> and abort all these steps.

    2. Let |layoutDefinitionMap| be {{LayoutWorkletGlobalScope}}'s <a>layout definitions</a> map.

    3. If |layoutDefinitionMap|[|name|] <a for=map>exists</a> <a>throw</a> a
        "<a>InvalidModificationError</a>" <a>DOMException</a> and abort all these steps.

    4. Let |inputProperties| be an empty <code>sequence&lt;DOMString></code>.

    5. Let |inputPropertiesIterable| be the result of <a>Get</a>(|layoutCtor|, "inputProperties").

    6. If |inputPropertiesIterable| is not undefined, then set |inputProperties| to the result of
        <a>converting</a> |inputPropertiesIterable| to a <code>sequence&lt;DOMString></code>. If an
        exception is <a>thrown</a>, rethrow the exception and abort all these steps.

        Note: The list of CSS properties provided by the input properties getter can either be
            custom or native CSS properties.

        Note: The list of CSS properties may contain shorthands.

        Note: In order for a layout class to be forwards compatible, the list of CSS properties can
            also contains currently invalid properties for the user agent. For example
            <code>margin-bikeshed-property</code>.

    7. Let |childInputProperties| be an empty <code>sequence&lt;DOMString></code>.

    8. Let |childInputPropertiesIterable| be the result of <a>Get</a>(|layoutCtor|,
        "childInputProperties").

    9. If |childInputPropertiesIterable| is not undefined, then set |childInputProperties| to the
        result of <a>converting</a> |childInputPropertiesIterable| to a
        <code>sequence&lt;DOMString></code>. If an exception is <a>thrown</a>, rethrow the exception
        and abort all these steps.

    10. Let |childDisplay| be a {{ChildDisplayType}} set to <code>"block"</code>.

    11. Let |childDisplayValue| be the result of <a>Get</a>(|layoutCtor|, "childDisplay").

    12. If |childDisplayValue| if not undefined, then then |childDisplay| to the result of
        <a>converting</a> |childDisplayValue| to a {{ChildDisplayType}}. If an exception is
        <a>thrown</a>, rethrow the exception and abort all these steps.

    13. If the result of <a>IsConstructor</a>(|layoutCtor|) is false, <a>throw</a> a
        <a>TypeError</a> and abort all these steps.

    14. Let |prototype| be the result of <a>Get</a>(|layoutCtor|, "prototype").

    15. If the result of <a>Type</a>(|prototype|) is not Object, <a>throw</a> a <a>TypeError</a> and
        abort all these steps.

    16. Let |layout| be the result of <a>Get</a>(|prototype|, <code>"layout"</code>).

    17. If the result of <a>IsCallable</a>(|layout|) is false, <a>throw</a> a <a>TypeError</a> and
        abort all these steps.

    18. If |layout|'s <code>\[[FunctionKind]]</code> internal slot is not <code>"generator"</code>,
        <a>throw</a> a <a>TypeError</a> and abort all these steps.

    19. Let |contentSize| be the result of <a>Get</a>(|prototype|, <code>"contentSize"</code>).

    20. If the result of <a>IsCallable</a>(|contentSize|) is false, <a>throw</a> a <a>TypeError</a>
        and abort all these steps.

    21. If |contentSize|'s <code>\[[FunctionKind]]</code> internal slot is not
        <code>"generator"</code>, <a>throw</a> a <a>TypeError</a> and abort all these steps.

    22. Let |definition| be a new <a>layout definition</a> with:

        - <a>class constructor</a> being |layoutCtor|.

        - <a>layout generator function</a> being |layout|.

        - <a>content size generator function</a> being |contentSize|.

        - <a>constructor valid flag</a> being <b>true</b>.

        - <a for="layout definition">input properties</a> being |inputProperties|.

        - <a for="layout definition">child input properties</a> being |childInputProperties|.

        - <a for="layout definition">child display</a> being |childDisplay|.

    23. <a for=map>Set</a> |layoutDefinitionMap|[|name|] to |definition|.

    24. <a>Queue a task</a> to run the following steps:

        1. Let |documentLayoutDefinitionMap| be the associated <a>document's</a> <a>document layout
            definitions</a> <a>map</a>.

        2. Let |documentDefinition| be a new <a>document layout definition</a> with:

            - <a for="document layout definition">input properties</a> being |inputProperties|.

            - <a for="document layout definition">child input properties</a> being
                |childInputProperties|.

            - <a for="document layout definition">child display</a> being |childDisplay|.

        3. If |documentLayoutDefinitionMap|[|name|] <a for=map>exists</a>, run the following steps:

            1. Let |existingDocumentDefinition| be the result of <a for=map>get</a>
                |documentLayoutDefinitionMap|[|name|].

            2. If |existingDocumentDefinition| is <code>"invalid"</code>, abort all these steps.

            3. If |existingDocumentDefinition| and |documentDefinition| are not equivalent, (that is
                <a for="document layout definition">input properties</a>, <a for="document layout
                definition">child input properties</a>, and <a for="document layout
                definition">child display</a> are different), then:

                <a for=map>Set</a> |documentLayoutDefinitionMap|[|name|] to <code>"invalid"</code>.

                Log an error to the debugging console stating that the same class was registered
                with different <code>inputProperties</code>, <code>childInputProperties</code>, or
                <code>childDisplay</code>.

        4. Otherwise, <a for=map>set</a> |documentLayoutDefinitionMap|[|name|] to
            |documentDefinition|.

<div class='note'>
    Note: The shape of the class should be:
    <pre class='lang-javascript'>
        class MyLayout {
            static get inputProperties() { return ['--foo']; }
            static get childrenInputProperties() { return ['--bar']; }
            static get childDisplay() { return 'normal'; }

            *contentSize(children, styleMap) {
                // min/max content size code goes here.
            }

            *layout(constraintSpace, children, styleMap, breakToken) {
                // Layout code goes here.
            }
        }
    </pre>
</div>
</div>

Layout Engine {#layout-engine}
------------------------------

<pre class="idl">
[Exposed=LayoutWorklet]
interface FragmentRequest {
  // Has internal slots:
  // [[layoutChild]] - The layout child to generate the fragment for.
  // [[constraintSpace]] - The constraint space to perform layout in.
  // [[breakToken]] - The break token to resume the layout with.
};

[Exposed=LayoutWorklet]
interface ContentSizeRequest {
  // Has internal slots:
  // [[layoutChild]] - The layout child to calculate the content size for.
};
</pre>

The layout method and content size method on the author supplied layout class is a generator
function instead of a regular javascript function. This is for user-agents to be able to support
asynchronous and parallel layout engines.

When an author invokes the {{LayoutChild/layoutNextFragment()}} method on a {{LayoutChild}} the
user-agent doesn't synchronously generate a {{Fragment}} to return to the author's code. Instead it
returns a {{FragmentRequest}}. This is a completely opaque object to the author but contains
internal slots which encapsulates the {{LayoutChild/layoutNextFragment()}} method call.

When a {{FragmentRequest}}(s) are yielded from a layout generator object the user-agent's
layout engine may run the algorithm asynchronously with other work, and/or on a different thread of
execution. When {{Fragment}}(s) have been produced by the engine, the user-agent will "tick" the
generator object with the resulting {{Fragment}}(s).

<div class="example">
An example layout engine written in javascript is shown below.

<pre class="lang-javascript">
class LayoutEngine {
  // This function takes the root of the box-tree, a ConstraintSpace, and a
  // BreakToken to (if paginating for printing for example) and generates a
  // Fragment.
  layoutEntry(rootBox, rootPageConstraintSpace, breakToken) {
    return layoutFragment({
      box: rootBox,
      constraintSpace: rootPageConstraintSpace,
      breakToken: breakToken,
    });
  }

  // This function takes a FragmentRequest and calls the appropriate layout
  // algorithm to generate the a Fragment.
  layoutFragment(fragmentRequest) {
    const box = fragmentRequest.layoutChild;
    const algorithm = selectLayoutAlgorithmForBox(box);
    const fragmentRequestGenerator = algorithm.layout(
        fragmentRequest.constraintSpace,
        box.children,
        box.styleMap,
        fragmentRequest.breakToken);

    let nextFragmentRequest = fragmentRequestGenerator.next();

    while (!nextFragmentRequest.done) {
      // A user-agent may decide to perform layout to generate the fragments in
      // parallel on separate threads. This example performs them synchronously
      // in order.
      let fragments = nextFragmentRequest.value.map(layoutFragment);

      // A user-agent may decide to yield for other work (garbage collection for
      // example) before resuming this layout work. This example just performs
      // layout synchronously without any ability to yield.
      nextFragmentRequest = fragmentRequestGenerator.next(fragments);
    }

    return nextFragmentRequest.value; // Return the final Fragment.
  }
}
</pre>
</div>

TODO explain parallel layout + {{FragmentRequest}}, etc.

Performing Layout {#performing-layout}
--------------------------------------

<pre class='idl'>
// This is the final return value from the author defined layout() method.
dictionary FragmentResultOptions {
    double inlineSize = 0;
    double blockSize = 0;
    sequence&lt;Fragment> childFragments = [];
    BreakTokenOptions breakToken = null;
    double alignmentBaseline = null;
};

dictionary ContentSizeResultOptions {
    double maxContentSize;
    double minContentSize;
};
</pre>

Issue: Specify how we do min/max content contributions.

Issue: Need to specify that the {{LayoutChild}} objects should remain the same between layouts so
    the author can store information? Not sure.

When the user agent wants to <dfn>generate a fragment</dfn> of a <a>layout API formatting
context</a> for a given |box|, |constraintSpace|, |children| and an optional |breakToken| it
<em>must</em> run the following steps:

    1. If the <a>layout valid flag</a> for the |box| is <a>layout-valid</a> the user agent
        <em>may</em> use a fragment from a previous invocation of this algorithm if the |box|,
        |constraintSpace|, |children| and optional |breakToken| are the same. If so it <em>may</em>
        abort all these steps and use the cached fragment.

        Issue: The above is too limiting wrt. the layout valid flag. Need to separate out the produce
            the fragment step, with the cache invalidation.

        Note: The user agent for implementation reasons may also continue with all these steps in this
            case. It can do this every frame, or multiple times per frame.

    2. Let |layoutFunction| be the <<layout()>> or <<inline-layout()>> for the <a>computed value</a>
        of 'display' on the |box|.

    3. Let |name| be the first argument of the |layoutFunction|.

    4. Let |workletGlobalScope| be a {{LayoutWorkletGlobalScope}} from the list of <a>worklet's
        WorkletGlobalScopes</a> from the layout {{Worklet}}.

        The user agent <em>may</em> also <a>create a WorkletGlobalScope</a> given the layout 
        {{Worklet}} and use that.

        Note: The user agent <em>may</em> use any policy for which {{LayoutWorkletGlobalScope}} to
            select or create. It may use a single {{LayoutWorkletGlobalScope}} or multiple and
            randomly assign between them.

    5. Let |definition| be the result of looking up |name| on the |workletGlobalScope|'s <a>layout
        definitions</a> <a>map</a>.

        If |definition| does not exist, let the fragment output be an <a>invalid fragment</a> and
        abort all these steps.

        Issue: Define what an "invalid fragment" is.
            <dfn>invalid fragment</dfn>

    6. Let |layoutInstance| be the result of looking up the <a>layout instance</a> on the |box|. If
        |layoutInstance| is null run the following substeps.

        1. If the <a>constructor valid flag</a> on |definition| is false, let the
            fragment output be an <a>invalid fragment</a> and abort all these steps.

        2. Let |layoutCtor| be the <a>class constructor</a> on |definition|.

        3. Let |layoutInstance| be the result of <a>Construct</a>(|layoutCtor|).

            If <a>Construct</a> throws an exception, set the |definition|'s <a>constructor valid
            flag</a> to false, let the fragment output be an <a>invalid fragment</a> and abort all
            these steps.

        4. Set <a>layout instance</a> on |box| to |layoutInstance|.

        Note: <a>Layout instance</a> will be set to null whenever the computed style of 'display' on
            |box| changes.

    7. Let |layoutGeneratorFunction| be the result of looking up the <a>layout generator
        function</a>.

    8. Let |inputProperties| be the result of looking up |name| on the associated <a>document</a>'s
        <a>document layout definitions</a> <a>map</a>.

    9. Let |styleMap| be a new {{StylePropertyMapReadOnly}} populated with <em>only</em> the
        <a>computed value</a>'s for properties listed in |inputProperties|.

    10. Let |layoutGenerator| be the result of <a>Invoke</a>(|layoutGeneratorFunction|,
        |layoutInstance|, «|constraintSpace|, |children|, |styleMap|, |breakToken|»).

    12. Let |childFragmentResults| be «» (the empty list).

    11. Let |nextResult| be the result of calling <a>Invoke</a>(<code>next</code>,
        |layoutGenerator|, |childFragmentResults|).

    12. Perform the following substeps until the result of <a>Get</a>(|nextResult|,
        <code>"done"</code>) is <code>true</code>.

        1. Set |childFragmentResults| be «» (the empty list).

        2. Let |fragmentRequests| be the result of <a>Get</a>(|nextResult|, <code>"value"</code>).

        3. For each |fragmentRequest| in |fragmentRequests| perform the following substeps:

            1. Let |layoutChild| be result of looking up the internal slot
                <code>\[[layoutChild]]</code> on |fragmentRequest|.

            2. Let |childConstraintSpace| be the result of looking up the internal slot
                <code>\[[childConstraintSpace]]</code> on |fragmentRequest|.

            3. Let |childBreakToken| be the result of looking up the internal slot
                <code>\[[childBreakToken]]</code> on |fragmentRequest|.

            4. Let |childFragmentResult| be the result of invoking <a>generate a fragment</a> with
                the arguments |layoutChild|, |childConstraintSpace|, |childBreakToken|.

                The user agent <em>may</em> perform this step <a>in parallel</a>.

            5. Append |childFragmentResult| to |childFragmentResults|.

        4. Let |nextResult| be the result of calling <a>Invoke</a>(<code>next</code>,
            |layoutGenerator|, |childFragmentResults|).

    13. Let |fragmentResult| be the result of calling <a>Get</a>(|nextResult|,
            <code>"value"</code>).

    14. Let |fragment| be a <a>fragment</a> with the following properties:

      - The <a>inline size</a> is set to |fragmentResult|'s {{FragmentResultOptions/inlineSize}}.

      - The <a>block size</a> is set to |fragmentResult|'s {{FragmentResultOptions/blockSize}}.

          Note: In a future level of the specification there may be a way to more efficiently abort
              a layout given a "scroll trigger line" on the constraint space.

          Issue: REMOVE THIS.

      - The children fragments of the |fragment| is set from |fragmentResult|'s
          {{FragmentResultOptions/childFragments}}. The ordering <em>is</em> important as this is
          dictates their paint order (described in [[#layout-api-containers]]). Their position
          relative to the <b>border box</b> of the |fragment| should be based off the author
          specified {{Fragment/inlineOffset}} and {{Fragment/blockOffset}}.

      - The <b>fragmentation break</b> is set to |fragmentResult|'s
          {{FragmentResultOptions/breakToken}}.

      - The <a>alignment baseline</a> is set to |fragmentResult|'s
          {{FragmentResultOptions/alignmentBaseline}} if not null, otherwise it is set to:
              - The {{Fragment/alignmentBaseline}} of the first child fragment if present.

              - The {{FragmentResultOptions/blockSize}} of the fragment.

    15. Return |fragment|.
