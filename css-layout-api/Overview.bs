<pre class='metadata'>
Title:  CSS Layout API Level 1
Status: DREAM
Group: houdini
ED: https://drafts.css-houdini.org/css-layout-api-1/
Shortname: css-layout-api
Level: 1
Abstract:
Editor: Greg Whitworth, gwhit@microsoft.com 
Editor: Ian Kilpatrick, ikilpatrick@chromium.org
Editor: Tab Atkins, jackalmage@gmail.com
Editor: Shane Stephens, shanestephens@google.com
Editor: Robert O'Callahan, robert@ocallahan.org
Editor: Rossen Atanassov, rossen.atanassov@microsoft.com
</pre>

<pre class="link-defaults">
spec:css-break-3; type:dfn; text:fragment
spec:css-display-3; type:dfn; text:box
spec:css-display-3; type:value; for:display; text:none
spec:dom; type:dfn; text:element
</pre>

<pre class="anchors">
urlPrefix: https://heycam.github.io/webidl/; type: dfn;
    text: NotSupportedError
    urlPrefix: #dfn-;
        text: callback this value
        text: exception
        text: throw
        url: throw; text: thrown
    url: es-invoking-callback-functions; text: Invoke
urlPrefix: https://tc39.github.io/ecma262/#sec-; type: dfn;
    text: constructor
    text: Construct
    text: IsArray
    text: IsCallable
    text: IsConstructor
    text: HasProperty
    url: get-o-p; text: Get
    url: terms-and-definitions-function; text: function
    urlPrefix: native-error-types-used-in-this-standard-
        text: TypeError
</pre>

Introduction {#intro}
=====================

The layout stage of CSS is responsible for generating and positioning <a>fragments</a> from the
<a>box tree</a>.

This specification describes an API which allows developers to layout a <a>box</a> in response to
computed style and <a>box</a> tree changes.

Layout API Containers {#layout-api-containers}
==============================================

<pre class="propdef">
    Name: display
    New values: layout(<<ident>>) | inline-layout(<<ident>>)
</pre>

<dl dfn-for="display" dfn-type=value>
    <dt><dfn>layout()</dfn>
    <dd>
        This value causes an element to generate a block-level <a>layout API container</a> box.
    <dt><dfn>inline-layout()</dfn>
    <dd>
        This value causes an element to generate an inline-level <a>layout API container</a> box.
</dl>


A <dfn>layout API container</dfn> is the box generated by an element with a computed 'display' of
''layout()'' or ''inline-layout()''.

A <a>layout API container</a> establishes a new <dfn>layout API formatting context</dfn> for its
contents. This is the same as establishing a block formatting context, except that the layout
provided by the author is used instead of the block layout.
For example, floats do not intrude into the layout API container, and the layout API container's
margins do not collapse with the margins of its contents.

<a>Layout API containers</a> form a containing block for their contents
<a href="https://www.w3.org/TR/CSS2/visudet.html#containing-block-details">exactly like block
containers do</a>. [[!CSS21]]

Note: In a future level of the specification there may be a way to override the containing block
    behaviour.

The 'overflow' property applies to <a>layout API containers</a>. This is discussed (TODO: writing
about scrollbars).

As the layout is entirely up to the author properties which are used in other layout modes (e.g.
flex, block) may not apply. For example an author may not call respect the 'width' or 'height'
properties.

If an element's specified 'display' is ''inline-layout()'', then its 'display' property computes to
''layout()'' in certain circumstances: the table in <a
href="https://www.w3.org/TR/CSS2/visuren.html#dis-pos-flo">CSS 2.1 Section 9.7</a> is amended to
contain an additional row, with ''inline-layout()'' in the "Specified Value" column and ''layout()''
in the "Computed Value" column.

Layout API Model and Terminology {#layout-api-model-and-terminology}
====================================================================

This section gives an overview of the Layout API given to authors.

The <dfn>current layout</dfn> is the layout algorithm for the <a>box</a> we are currently performing
layout for.

The <dfn>parent layout</dfn> is the layout algorithm for the <a>box</a>'s direct parent, (the layout
algorithm which is requesting the <a>current layout</a> to be performed).

A <dfn>child layout</dfn> is the layout algorithm for a {{LayoutChild}} of the <a>current layout</a>.

Layout Children {#layout-children}
----------------------------------

<pre class='idl'>
interface LayoutChild {
    FragmentRequestToken doLayout(ConstraintSpace space, ChildBreakToken breakToken);
};

interface InlineLayoutChild : LayoutChild {
};

interface BoxLayoutChild : LayoutChild {
    readonly attribute StylePropertyMapReadOnly styleMap;
};
</pre>

A {{LayoutChild}} represents either a CSS generated <a>box</a> or a sequence of non-<a>atomic inline
boxes</a> before layout has occurred. (The box or boxes will all have a computed value of 'display'
that is not ''none'').

The {{LayoutChild}} does not contain any layout information itself (like inline or block size) but
can be used to generate {{Fragment}}s which do contain layout information.

An author cannot construct a {{LayoutChild}} with this API, this happens at a separate stage of the
rendering engine (post style resolution).

A {{InlineLayoutChild}} represents a sequence of non-<a>atomic inlines</a>. It does not have a
single <a>computed style</a> associated with it as it may contain multiple inline boxes inside it
with different <a>computed style</a>.

<div class="note">
    Note: As an example the following would be placed into a single {{InlineLayoutChild}}:
    <pre class="lang-html">
        This is a next node, &lt;span>with some additional styling,
        that may&lt;/span> break over&lt;br>multiple lines.
    </pre>
</div>

Multiple non-<a>atomic inlines</a> are placed within the same {{InlineLayoutChild}} to allow
rendering engines to perform text shaping across element boundaries.

<div class="note">
    Note: As an example the following should produce one {{Fragment}} but is from
    three non-<a>atomic inlines</a>:
    <pre class="lang-html">
        &#x639;&lt;span style="color: blue">&#x639;&lt;/span>&#x639;
    </pre>
</div>

Note: In a future level of the specification there may be a way to query the <a>computed style</a>
      of ranges inside a {{InlineLayoutChild}}.

A {{BoxLayoutChild}} represents a single <a>box</a>. It does have an associated computed style which
can be asscessed by {{BoxLayoutChild/styleMap}}. The {{BoxLayoutChild/styleMap}} will only contain
properties which are listed in the <a>child input properties</a> array.

A {{BoxLayoutChild}} could be generated by:

 - An <a>element</a>.

 - A <a>::before</a> or <a>::after</a> pseudo-element.

    Note: Other pseudo-elements such as <a>::first-letter</a> or <a>::first-line</a> do not generate
        a {{BoxLayoutChild}} for layout purposes. They are additional styling information for a text
        node.

 - An <a>anonymous box</a>. For example an anonymous box may be inserted as a result of:

    - A <a>Text</a> node which has undergone <a>blockification</a>. (Or more generally a
        {{InlineLayoutChild}} which has undergone <a>blockification</a>).

    - An element with ''display: table-cell'' which doesn't have a parent with ''display: table''.

 - An <a>atomic inline</a>.

<div class="note">
    Note: As an example the following would be placed into three {{BoxLayoutChild}}ren:
    <pre class="lang-html">
        &lt;style>
          #box::before { content: 'hello!'; }
        &lt;/style>
        <!-- A ::before pseudo-element is inserted here. -->
        &lt;div id="box">A block level box with text.&lt;/div>
        &lt;img src="..." />
    </pre>
</div>

An array of {{LayoutChild}}ren is passed into the <a>layout method</a> which represents the children
of the current box which is being laid out.

To perform layout on a box the author can invoke the {{LayoutChild/doLayout()}} method. This will
produce a {{Fragment}} which contains layout information.

The {{LayoutChild/doLayout()}} method may be invoked multiple times with different arguments to
query the {{LayoutChild}} for different layout information.

Layout Fragments {#layout-fragments}
------------------------------------

<pre class='idl'>
interface Fragment {
    readonly attribute double inlineSize;
    readonly attribute double blockSize;

    readonly attribute double inlineOverflowSize;
    readonly attribute double blockOverflowSize;

    attribute double inlineOffset;
    attribute double blockOffset;

    readonly attribute ChildBreakToken? breakToken;

    readonly attribute double dominantBaseline;
};
</pre>

A {{Fragment}} represents a CSS <a>fragment</a> of a {{LayoutChild}} after layout has occurred on
that child. This is produced by the {{LayoutChild/doLayout()}} method.

The {{Fragment}} has {{Fragment/inlineSize}} and {{Fragment/blockSize}} attributes, which are set by
the respective child's layout algorithm. They cannot be changed. If the <a>current layout</a>
requires a different {{Fragment/inlineSize}} or {{Fragment/blockSize}} the author must perform
{{LayoutChild/doLayout()}} again with different arguments in order to get different results.

The {{Fragment}} has {{Fragment/inlineOverflowSize}} and {{Fragment/blockOverflowSize}} attributes.
This is the size of the overflow area of the fragment. If the fragment didn't overflow these
attributes will be the same as {{Fragment/inlineSize}} and {{Fragment/blockSize}} respectively.

The author inside the current layout can position a resulting {{Fragment}} by setting its
{{Fragment/inlineOffset}} and {{Fragment/blockOffset}} attributes. If not set by the author they
default to zero.

<div class="example">
The layout algorithm performs a block-like layout (positioning fragments sequentically in the block
direction), while centering its children in the inline direction.

<pre class="lang-javascript">
registerLayout('block-like', class extends Layout {
    static blockifyChildren = true;
    static inputProperties = super.inputProperties;

    *layout(space, children, styleMap) {
        const inlineSize = resolveInlineSize(space, styleMap);

        const bordersAndPadding = resolveBordersAndPadding(constraintSpace, styleMap);
        const scrollbarSize = resolveScrollbarSize(constraintSpace, styleMap);
        const availableInlineSize = inlineSize -
                                    bordersAndPadding.inlineStart -
                                    bordersAndPadding.inlineEnd -
                                    scrollbarSize.inline;

        const availableBlockSize = resolveBlockSize(constraintSpace, styleMap) -
                                   bordersAndPadding.blockStart -
                                   bordersAndPadding.blockEnd -
                                   scrollbarSize.block;

        const childFragments = [];
        const childConstraintSpace = new ConstraintSpace({
            inlineSize: availableInlineSize,
            blockSize: availableBlockSize,
        });

        let maxChildInlineSize = 0;
        let blockOffset = bordersAndPadding.blockStart;

        for (let child of children) {
            const fragment = yield child.doLayout(childConstraintSpace);

            // Position the fragment in a block like manner, centering it in the
            // inline direction.
            fragment.blockOffset = blockOffset;
            fragment.inlineOffset = Math.max(
                bordersAndPadding.inlineStart,
                (availableInlineSize - fragment.inlineSize) / 2);

            maxChildInlineSize =
                Math.max(maxChildInlineSize, childFragments.inlineSize);
            blockOffset += fragment.blockSize;
        }

        const inlineOverflowSize = maxChildInlineSize + bordersAndPadding.inlineEnd;
        const blockOverflowSize = blockOffset + bordersAndPadding.blockEnd;
        const blockSize = resolveBlockSize(
            constraintSpace, styleMap, blockOverflowSize);

        return {
            inlineSize: inlineSize,
            blockSize: blockSize,
            inlineOverflowSize: inlineOverflowSize,
            blockOverflowSize: blockOverflowSize,
            childFragments: childFragments,
        };
    }
});
</pre>
</div>

The {{Fragment}}'s {{Fragment/breakToken}} specifies where the {{LayoutChild}} last fragmented. If
the {{Fragment/breakToken}} is null the {{LayoutChild}} wont produce any more {{Fragment}}s for that
token chain. The {{Fragment/breakToken}} can be passed to the {{LayoutChild/doLayout()}} function to
produce the next {{Fragment}} for a particular child. The {{Fragment/breakToken}} cannot be changed.
If the <a>current layout</a> requires a different {{Fragment/breakToken}} the author must perform
{{LayoutChild/doLayout()}} again with different arguments.

The {{Fragment}}'s {{Fragment/dominantBaseline}} attribute specify where the dominant baseline is
positioned relative to the block start of the fragment. It cannot be changed.

Note: In a future level of the specification there may be a way to query for additional baseline
      information, for example where the alphabetic or center baseline is positioned.

Constraint Spaces {#constraint-spaces}
--------------------------------------

<pre class='idl'>
[Constructor(optional ConstraintSpaceOptions options)]
interface ConstraintSpace {
    readonly attribute double inlineSize;
    readonly attribute double blockSize;

    readonly attribute boolean inlineSizeFixed;
    readonly attribute boolean blockSizeFixed;

    readonly attribute boolean inlineShrinkToFit;

    readonly attribute double percentageInlineSize;
    readonly attribute double percentageBlockSize;

    readonly attribute BlockFragmentationType blockFragmentationType;
};

dictionary ConstraintSpaceOptions {
    double inlineSize = Infinity;
    double blockSize = Infinity;

    boolean inlineSizeFixed = false;
    boolean blockSizeFixed = false;

    boolean inlineShrinkToFit = false;

    double? percentageInlineSize = null;
    double? percentageBlockSize = null;

    BlockFragmentationType blockFragmentationType = "none";
};

enum BlockFragmentationType { "none", "page", "column", "region" };
</pre>

A {{ConstraintSpace}} is passed into the <a>layout method</a> which represents the available space
for the <a>current layout</a> to perform layout inside. It is also used to pass information about
the available space into a <a>child layout</a>.

The {{ConstraintSpace}} has {{ConstraintSpace/inlineSize}} and {{ConstraintSpace/blockSize}}
attributes. This represents the <a>available space</a> for a {{Fragment}} which the layout should
respect.

Note: Some layouts may need to produce a {{Fragment}} which exceed this size. For example a
    <a>replaced element</a>. The <a>parent layout</a> should expect this to occur and deal with it
    appropriately.

A <a>parent layout</a> may require the <a>current layout</a> to be exactly a particular size. If
the {{ConstraintSpace/inlineSizeFixed}} or {{ConstraintSpace/blockSizeFixed}} are true the
<a>current layout</a> should produce a {{Fragment}} with a fixed size in the appropriate direction.

<div class="example">
The layout algorithm performs a flexbox-like distribution of spare space in the inline direction. It
creates child constraint spaces which specify that a child should be a fixed inline size.

<pre class="lang-javascript">
registerLayout('flex-distribution-like', class {
    *layout(space, children, styleMap, breakToken) {
        const inlineSize = resolveInlineSize(space, styleMap);

        const bordersAndPadding = resolveBordersAndPadding(constraintSpace, styleMap);
        const scrollbarSize = resolveScrollbarSize(constraintSpace, styleMap);
        const availableInlineSize = inlineSize -
                                    bordersAndPadding.inlineStart -
                                    bordersAndPadding.inlineEnd -
                                    scrollbarSize.inline;

        const availableBlockSize = resolveBlockSize(constraintSpace, styleMap) -
                                   bordersAndPadding.blockStart -
                                   bordersAndPadding.blockEnd -
                                   scrollbarSize.block;

        const unconstrainedSizes = [];
        const childConstraintSpace = new ConstraintSpace({
            inlineShrinkToFit: true,
            inlineSize: availableInlineSize,
            blockSize: availableBlockSize,
        });
        let totalSize = 0;

        // Calculate the unconstrained size for each child.
        for (let child of children) {
            const fragment = yield child.doLayout(childConstraintSpace);
            unconstrainedSizes.push(fragment.inlineSize);
            totalSize += fragment.inlineSize;
        }

        // Distribute spare space between children.
        const remainingSpace = Math.max(0, inlineSize - totalSize);
        const extraSpace = remainingSpace / children.length;
        const childFragments = [];
        let inlineOffset = 0;
        let maxChildBlockSize = 0;
        for (let i = 0; i < children.length; i++) {
            let fragment = yield child.doLayout(new ConstraintSpace({
                inlineSize: unconstrainedSizes[i] + extraSpace,
                inlineSizeFixed: true,
                blockSize: availableBlockSize
            }));

            fragment.inlineOffset = inlineOffset;
            inlineOffset += fragment.inlineSize;

            maxChildBlockSize = Math.max(maxChildBlockSize, fragment.blockSize);

            childFragments.push(fragment);
        }

        // Resolve our block size.
        const blockSize = resolveBlockSize(constraintSpace, styleMap, maxChildBlockSize);

        return {
            inlineSize: inlineSize,
            blockSize: blockSize,
            inlineOverflowSize: Math.max(inlineSize, totalSize),
            blockOverflowSize: maxChildBlockSize,
            childFragments: childFragments,
        };
    }
});
</pre>
</div>

The {{ConstraintSpace}} has a {{ConstraintSpace/inlineShrinkToFit}} attribute. This is used to
indicate that the layout should treat ''auto'' as ''fit-content'' instead.

The {{ConstraintSpace}} has {{ConstraintSpace/percentageInlineSize}} and
{{ConstraintSpace/percentageBlockSize}} attributes. These represent the size that a layout
percentages should be resolved against while performing layout.

The {{ConstraintSpace}} has a {{ConstraintSpace/blockFragmentationType}} attribute. The <a>current
layout</a> should produce a {{Fragment}} which fragments at the {{ConstraintSpace/blockSize}} if
possible. 

The <a>current layout</a> may choose not to fragment a {{LayoutChild}} based on the
{{ConstraintSpace/blockFragmentationType}}, for example if the child has a property like
''break-inside: avoid-page;''.

Breaking and Fragmentation {#breaking-and-fragmentation}
--------------------------------------------------------

<pre class="idl">
interface ChildBreakToken {
    readonly attribute BreakType breakType;
    readonly attribute Box box;
};

interface BreakToken {
    readonly attribute sequence&lt;ChildBreakToken> childBreakTokens;
    readonly attribute Object data;
};

dictionary BreakTokenOptions {
    sequence&lt;ChildBreakToken> childBreakTokens;
    Object data = null;
};

enum BreakType { "none", "inline", "inline-hyphen", "column", "page", "region" };
</pre>

Issue(w3c/css-houdini-drafts#258): What type of {{BreakType}}s are needed?

A {{LayoutChild}} can produce multiple {{Fragment}}s. A {{BoxLayoutChild}} may fragment in the block
direction if a {{ConstraintSpace/blockFragmentation}} is not none. A {{InlineLayoutChild}} may
fragment in the inline direction.

A subsequent {{Fragment}} is produced by using the previous {{Fragment}}'s {{Fragment/breakToken}}.
This tells the <a>child layout</a> to produce a {{Fragment}} starting at the point encoded in the
{{ChildBreakToken}}.

When returning a list of {{Fragment}}s from the <a>current layout</a> the list of {{Fragment}}s must
have a contiguous set of {{Fragment/breakToken}}s.

<div class="example">
TODO: add example showing non-contiguous set of fragments.
</div>

<div class="example">
This example shows how to use a previous {{Fragment}}'s {{Fragment/breakToken}} to produce the next
{{Fragment}} in the sequence.

<pre class="lang-javascript">
registerLayout('fragmenting', class {
    *layout(space, children, styleMap, breakToken) {

      // ... snip ...

      const fragments = [];
      let breakToken = null;
      for (let child of children) {
          // This do-while loop will keep producing fragments for a child box
          // until it cannot produce any more.
          do {
              // ... snip ... (setting up child constraint space).

              let fragment = yield child.doLayout(childSpace, breakToken);
              breakToken = fragment.breakToken;

              fragments.push(fragment);
          } while (breakToken);
      }

      // ... snip ...

    }
});
</pre>
</div>

<div class="example">
This example shows how to use resume a layout given a breakToken.

<pre class="lang-javascript">
registerLayout('fragmenting', class {
    *layout(space, children, styleMap, breakToken) {
        const fragments = [];

        // Produce the next fragment in the sequence if we have a breakToken.
        if (breakToken) {
            for (let childBreakToken of breakToken.childBreakTokens) {
                let fragment = yield childBreakToken.box.doLayout(
                        childSpace, childBreakToken);

                fragments.push(fragment);
            }
        }
    }
});
</pre>
</div>

Layout {#layout}
================

This section describes how the CSS Layout API interacts with the user agent's layout engine.

Layout Invalidation {#layout-invalidation}
------------------------------------------

A <a>document</a> has an associated <dfn>layout name to input properties map</dfn> and a <dfn>layout
name to child input properties map</dfn>. Initialy these maps are empty and are populated when
{{registerLayout(name, layoutCtor)}} is called.

Each <a>box</a> has an associated <dfn>layout valid flag</dfn>. It may be either
<dfn>layout-valid</dfn> or <dfn>layout-invalid</dfn>. It is initially set to <a>layout-invalid</a>.

When the <a>computed style</a> for a |box| changes, the user agent must run the following steps:
    1. Let |layoutFunction| be the <<layout()>> or <<inline-layout()>> function of the 'display'
        property on the <a>computed style</a> for the |box| if it exists. If it is a different type
        of value (e.g.  ''grid'') then abort all these steps.

    2. Let |name| be the first argument of the |layoutFunction|.

    3. Let |inputProperties| be the result of looking up |name| on <a>layout name to input
        properties map</a>.

    4. Let |childInputProperties| be the result of looking up |name| on <a>layout name to child
        input properties map<a>.

    5. For each |property| in |inputProperties|, if the |property|'s <a>computed value</a> has
        changed, set the <a>layout valid flag</a> on the <a>box</a> to <a>layout-invalid</a>.

    6. For each |property| in |childInputProperties|, if the |property|'s <a>computed value</a> has
        changed, set the <a>layout valid flag</a> on the <a>box</a> to <a>layout-invalid</a>.

When a child <a>box</a> represented by a {{BoxLayoutChild}} is added or removed from the <a>box
tree</a> or has its layout invalidated (from a computed style change). Set the <a>layout valid
flag</a> on the current <a>box</a> to <a>layout-invalid</a>.

When a child non-<a>atomic inline</a> represented by a {{InlineLayoutChild}} is added or removed
from the <a>box tree</a> or has its layout invalidated (from a computed style change, or if its text
has changed). Set the <a>layout valid flag</a> on the current <a>box</a> to <a>layout-invalid</a>.

Note: This only describes layout invalidatation as it relates to the CSS Layout API. All
    <a>boxes</a> conceptually have a <a>layout valid flag</a> and these changes are propogated
    through the <a>box tree</a>.

Layout Worklet {#layout-worklet}
--------------------------------

The {{layoutWorklet}} attribute allows access to the {{Worklet}} responsible for all the classes
which are related to layout.

The {{layoutWorklet}}'s <a>worklet global scope type</a> is {{LayoutWorkletGlobalScope}}.

<pre class='idl'>
partial interface CSS {
    [SameObject] readonly attribute Worklet layoutWorklet;
};
</pre>

The {{LayoutWorkletGlobalScope}} is the global execution context of the {{layoutWorklet}}.

<pre class='idl'>
[Global=(Worklet,LayoutWorklet),Exposed=LayoutWorklet]
interface LayoutWorkletGlobalScope : WorkletGlobalScope {
    void registerLayout(DOMString name, VoidFunction layoutCtor);
};
</pre>

Registering A Layout {#registering-layout}
------------------------------------------

A <dfn>layout definition</dfn> describes an author defined layout which can be referenced by the
<<layout()>> or <<inline-layout()>> functions. It consists of:

 - A <dfn>layout name</dfn>.

 - A <dfn>layout class constructor</dfn> which is the class <a>constructor</a>.

 - A <dfn>layout generator function</dfn> which is the layout <a>generator function</a> callback.

 - A <dfn>layout class constructor valid flag</dfn>.

The {{LayoutWorkletGlobalScope}} has a map of <b>layout name to layout definition map</b>. Initially
this map is empty; it is populated when {{registerLayout(name, layoutCtor)}} is called.

When the <dfn method for=LayoutWorkletGlobalScope>registerLayout(|name|, |layoutCtor|)</dfn> method
is called, the user agent <em>must</em> run the following steps:
    1. If the |name| exists as a key in the <a>layout name to layout definition map</dfn>,
        <a>throw</a> a <a>NotSupportedError</a> and abort all these steps.

    2. If the |name| is an empty string, <a>throw</a> a <a>TypeError</a> and abort all these steps.

    3. Let |inputProperties| be the result of <a>Get</a>(|layoutCtor|,
        <code>"inputProperties"</code>).

    4. If |inputProperties| is not undefined, and the result of <a>IsArray</a>(|inputProperties|) is
        false, <a>throw</a> a <a>TypeError</a> and abort all these steps.

        If |inputProperties| is undefined, let |inputProperties| be a new empty array.

    5. For each |item| in |inputProperties| perform the following substeps:

        1. If the result of <a>Type</a>(|item|) is not String, <a>throw</a> a <a>TypeError</a> and
            abort all these steps.

    6. Let |childInputProperties| be the result of <a>Get</a>(|layoutCtor|,
        <code>"childInputProperties"</code>).

    7. If |childInputProperties| is not undefined, and the result of
        <a>IsArray</a>(|childInputProperties|) is false, <a>throw</a> a <a>TypeError</a> and abort
        all these steps.

        If |childInputProperties| is undefined, let |childInputProperties| be a new empty array.

    8. For each |item| in |childInputProperties| perform the following substeps:

        1. If the result of <a>Type</a>(|item|) is not String, <a>throw</a> a <a>TypeError</a> and
            abort these steps.

    Note: The list of CSS properties provided by "inputProperties" or "childInputProperties" can
        either by custom or native CSS properties.

    Note: The list of CSS properties may contain shorthands.

    Note: In order for a layout class to be forwards compatible, the list of CSS properties can also
        contain currently invalid properties for the user agent. For example
        <code>margin-bikeshed-property</code>.

    9. Let |prototype| be the result of <a>Get</a>(|layoutCtor|, <code>"prototype"</code>).

    10. If the result of <a>Type</a>(|prototype|) is not Object, <a>throw</a> a <a>TypeError</a> and
        abort all these steps.

    11. Let |layout| be the result of <a>Get</a>(|prototype|, <code>"layout"</code>).

    12. If the result of <a>IsCallable</a>(|layout|) is false, <a>throw</a> a <a>TypeError</a> and
        abort all these steps.

    13. If |layout|'s <code>\[[FunctionKind]]</code> internal slot is not <code>"generator"</code>,
        <a>throw</a> a <a>TypeError</a> and abort all these steps.

    14. Let |definition| be a new <a>layout definition</a> with:

        - <a>layout name</a> being |name|.

        - <a>layout class constructor</a> being |layoutCtor|.

        - <a>layout generator function</a> being |layout|.

        - <a>layout class constructor valid flag</a> being true

    15. Add the key-value pair (|name| - |inputProperties|) to the <a>layout name to input
        properties map</a> of the associated <a>document</a>.

    16. Add the key-value pair (|name| - |childInputProperties|) to the <a>layout name to child
        input properties map</a> of the associated <a>document</a>.

    17. Add the key-value pair (|name| - |definition|) to the <a>layout name to layout definition
        map</a> of the associated <a>document</a>.

<div class='note'>
    The shape of the class should be:
    <pre class='lang-javascript'>
        class MyLayout {
            static get inputProperties() { return ['--foo'] }
            static get childrenInputProperties() { return ['--bar'] }

            *layout(constraintSpace, children, styleMap, breakToken) {
                // Etc.
            }
        }
    </pre>
</div>

Layout Engine {#layout-engine}
------------------------------

<pre class="idl">
interface FragmentRequestToken {
  // Has internal slots:
  // [[layoutChild]] - The layout child to generate the fragment for.
  // [[constraintSpace]] - The constraint space to perform layout in.
  // [[breakToken]] - The break token to resume the layout with.
};
</pre>

The layout method on the author supplied layout class is a generator function instead of a regular
javascript function. This is for user-agents to be able to support asynchronous and parallel layout
engines.

When an author invokes the {{LayoutChild/doLayout()}} method on a {{LayoutChild}} the user-agent
doesn't synchronously generate a {{Fragment}} to return to the author's code. Instead it returns a
{{FragmentRequestToken}}. This is a completely opaque object to the author but contains internal
slots which encapsulates the {{Box/doLayout()}} method call.

When a {{FragmentRequestToken}}(s) are yielded from a layout generator object the user-agent's
layout engine may run the algorithm asynchronously with other work, and/or on a different thread of
execution. When {{Fragment}}(s) have been produced by the engine, the user-agent will 'tick' the
generator object with the resulting {{Fragment}}(s).

Issue: Write algorithm "<dfn>generate a fragment</dfn>" which encapsulates this.

<div class="example">
An example layout engine written in javascript is shown below.

<pre class="lang-javascript">
class LayoutEngine {
  // This function takes the root of the box-tree, a ConstraintSpace, and a
  // BreakToken to (if paginating for printing for example) and generates a
  // Fragment.
  layoutEntry(rootBox, rootPageConstraintSpace, breakToken) {
    return layoutFragment({
      box: rootBox,
      constraintSpace: rootPageConstraintSpace,
      breakToken: breakToken,
    });
  }

  // This function takes a FragmentRequestToken and calls the appropriate layout
  // algorithm to generate the a Fragment.
  layoutFragment(fragmentRequest) {
    const box = fragmentRequest.box;
    const algorithm = selectLayoutAlgorithmForBox(box);
    const fragmentRequestGenerator = algorithm.layout(
        fragmentRequest.constraintSpace,
        box.children,
        box.styleMap,
        fragmentRequest.breakToken);

    let nextFragmentRequest = fragmentRequestGenerator.next();

    while (!nextFragmentRequest.done) {
      // A user-agent may decide to perform layout to generate the fragments in
      // parallel on separate threads. This example performs them synchronously
      // in order.
      let fragments = nextFragmentRequest.value.map(layoutFragment);

      // A user-agent may decide to yield for other work (garbage collection for
      // example) before resuming this layout work. This example just performs
      // layout synchronously without any ability to yield.
      nextFragmentRequest = fragmentRequestGenerator.next(fragments);
    }

    return nextFragmentRequest.value; // Return the final Fragment.
  }
}
</pre>
</div>

TODO explain parallel layout + {{FragmentRequestToken}}, etc.

Performing layout {#performing-layout}
--------------------------------------

<pre class='idl'>
dictionary LayoutResult {
    double inlineSize;
    double blockSize;
    sequence&lt;Fragment> fragments;
    BreakToken breakToken;
    double baseline;
};
</pre>

{{LayoutClass/layout()}} is invoked by the user agent when <a>generate a layout</a> for a <a>box</a>.

The user agent passes in:
  - The current children for the <a>box</a>, with only {{LayoutClass/childInputProperties}} on
    {{Box/styleMap}}
  - The available space defined by a {{ConstraintSpace}}
  - The computed style of the <a>box</a>, with only {{LayoutClass/inputProperties}}
  - The {{BreakToken}} if any, for where the <a>box</a> was last fragmented.

The author defined code should produce a {{LayoutResult}}.

The {{LayoutResult}} consists of:
 - A {{LayoutResult/minContent}} which represents the fragment's <a>min-content inline-size
    contribution</a>.
 - A {{LayoutResult/maxContent}} which represents the fragment's <a>max-content inline-size
    contribution</a>.
 - A {{LayoutResult/width}} which represents the fragment's resulting width.
 - A {{LayoutResult/height}} which represents the fragment's resulting height.
 - A list of {{LayoutResult/fragments}} which represents the fragment's direct child fragments.
 - A list of {{LayoutResult/unpositionedFragments}} which represents the fragment's children which
    should be positioned by a parent fragment.
 - A {{LayoutResult/breakToken}} which represents where the current layout's box last broke.
 - A {{LayoutResult/baseline}} which represents the baseline of the fragment.

Issue: Write the following into the algorithm.

If any {{Fragment}}s appear in both the list of {{LayoutResult/fragments}} or the list of
{{LayoutResult/unpositionedFragments}} the user agent should throw an error.

The user agent should check that a consistent set of {{Fragment}}s generated from a {{LayoutChild}}
is returned in either the list of {{LayoutResult/fragments}} or
{{LayoutResult/unpositionedFragments}}. (Consistent being that a {{Fragment/breakToken}} from one
{{Fragment}} was used to generate another {{Fragment}} in the set).

If any {{Fragment}}s appear more than once, the user agent should throw an error.

When the user agent wants to <dfn>generate a layout</dfn> of a <<layout()>> or <<inline-layout()>>
for a box it <em>must</em> run the following steps:

Issue: TODO specify these steps.

Examples {#examples}
====================

Example 1: A simple block layout {#example-1}
---------------------------------------------

<pre class='lang-javascript'>
// Inside LayoutWorkletGlobalScope

// Note this is meant to be similar (*not* the same) as a block layout.
// Everything is done in 'width' & 'height' for easy reading.
registerLayout('simple-flow', class {
    static get inputProperties() { return ['width', 'height'] }
    static get childrenInputProperties() { return ['x', 'y', 'position'] }

    layout(children, constraintSpace, styleMap, breakToken) {
        const absoluteChildren = [];
        const fixedChildren = [];
        const fragments = [];

        // Resolve our width using the available width in 'constraintSpace', and
        // our computed width property.
        let width = resolveWidth(constraintSpace, styleMap.get('width'));

        // Create a new constraint space for our children to consume.
        let childConstraintSpace = new ConstraintSpace(constraintSpace);
        childConstraintSpace.width = width;

        // Track the used height, min and max content.
        let height = 0;
        let minContent = 0;
        let maxContent = 0;

        for (let child of children) {
            // Check if the child is out of flow positioned.
            const childPosition = child.styleMap.get('position');

            if (childPosition == 'absolute') {
                absoluteChildren.push(child);
                continue;
            }

            if (childPosition == 'fixed') {
                fixedChildren.push(child);
                continue;
            }

            // Layout the in flow child.
            const childFragment = child.doLayout(childConstraintSpace);

            // Position the child.
            childFragment.x = 0;
            childFragment.y = height;

            // Update our current height, min and max content.
            height += childFragment.height;
            minContent = Math.max(childFragment.minContent, minContent);
            maxContent = Math.max(childFragment.maxContent, maxContent);
        }

        // Resolve the height.
        height = resolveHeight(constraintSpace, styleMap.get('height'), height);

        return {
            minContent: minContent,
            maxContent: maxContent,
            width: width,
            height: height,
            fragments: fragments,
            unPositionedChildren: absoluteChildren.concat(fixedChildren),
            breakToken: null
        };
    }
});
</pre>

<pre class='lang-markup'>
&lt;div id="myElement"&gt;
    &lt;div&gt;
        CSS is awesome.
    &lt;/div&gt;
&lt;/div&gt;

&lt;style&gt;
#myElement {
    display: layout('simple-flow');
}
&lt;/style&gt;
</pre>

Example 2: A simple line layout {#example-2}
--------------------------------------------

<pre class='lang-javascript'>
// Inside LayoutWorkletGlobalScope

// Note this is meant to be similar (*not* the same) as a inline layout.
// Everything is done in 'width' & 'height' for easy reading.
registerLayout('simple-inline-flow', class {
    static get inputProperties() { return ['width', 'height'] }
    static get childrenInputProperties() { return [] }

    layout(children, constraintSpace, styleMap, breakToken) {
        // Resolve our width using the available width in 'constraintSpace', and
        // our computed width property.
        const width = resolveWidth(constraintSpace, styleMap.get('width'));
        const fragments = [];
        let height = 0;

        // TODO compute these.
        let minContent = 0;
        let maxContent = 0;

        let childFragment = null;
        let lineFragments = [];
        let lineHeight = 0;
        let remainingLineWidth = width; // NOTE: should be helper on constraint space?

        const childIter = chidlren.values();
        let child = childIter.next().value;
        let breakToken = null;

        while (child) {
            // Create a new constraint space for the child, with all the current
            // positioned children.
            const childConstraintSpace = new ConstraintSpace(constraintSpace);
            childConstraintSpace.addExclusion(new ExclusionRect(width, height, 0, 0));
            childConstraintSpace.addExclusions(lineFragments);

            // Perform layout on the child.
            childFragment = child.doLayout(childConstraintSpace, breakToken);
            fragments.push(childFragment);

            // Check if we need to position the fragment on the next line.
            if (childFragment.width > remainingLineWidth) {
                // Need to start a new line.
                lineFragments = [];
                height += lineHeight;
                lineHeight = 0;
                remainingLineWidth = width;
            }

            // Position the fragment horizontally.
            childFragment.x = width - remainingLineWidth;

            lineFragments.push(childFragment);
            lineHeight = Math.max(lineHeight, childFragment.height);
            remainingLineWidth -= childFragment.width;

            // Update the line fragments positions, based on the new lineHeight.
            for (let frag of lineFragments) {
                frag.y = lineHeight - frag.height;
            }

            // Step to the next child if required.
            if (childFragment.breakToken) {
                breakToken = childFragment.breakToken;
            } else {
                child = childIter.next().value;
                breakToken = null;
            }
        }

        // Resolve the height.
        height = resolveHeight(constraintSpace, styleMap.get('height'), height);

        return {
            minContent: minContent,
            maxContent: maxContent,
            width: width,
            height: height,
            fragments: fragments,
            unpositionedFragments: [],
            breakToken: null
        };
    }
});
</pre>
