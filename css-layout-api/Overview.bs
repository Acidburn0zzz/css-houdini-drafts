<pre class='metadata'>
Title:  CSS Layout API Level 1
Status: DREAM
Group: houdini
ED: https://drafts.css-houdini.org/css-layout-api-1/
Shortname: css-layout-api
Level: 1
Abstract:
Editor: Greg Whitworth, gwhit@microsoft.com 
Editor: Ian Kilpatrick, ikilpatrick@chromium.org
Editor: Tab Atkins, jackalmage@gmail.com
Editor: Shane Stephens, shanestephens@google.com
Editor: Robert O'Callahan, robert@ocallahan.org
Editor: Rossen Atanassov, rossen.atanassov@microsoft.com
</pre>

<pre class="link-defaults">
spec:css-break-3; type:dfn; text:fragment
spec:css-display-3; type:dfn; text:box
spec:css-display-3; type:value; for:display; text:none
spec:dom; type:dfn; text:element
</pre>

Introduction {#intro}
=====================

The layout stage of CSS is responsible for generating and positioning <a>fragments</a> from the
<a>box tree</a>.

This specification describes an API which allows developers to layout a <a>box</a> in response to
computed style and <a>box</a> tree changes.

Layout Model and Terminology {#layout-model-and-terminology}
============================================================

The <dfn>current layout</dfn> is the layout algorithm for the <a>box</a> we are currently performing
layout for.

The <dfn>parent layout</dfn> is the layout algorithm for the <a>box</a>es direct parent, (the layout
algorithm which is requesting the <a>current layout</a> to be performed).

A <dfn>child layout</dfn> is the layout algorithm for a {{LayoutChild}} of the <a>current layout</a>.

Layout Children {#layout-children}
----------------------------------

<pre class='idl'>
interface LayoutChild {
    FragmentRequestToken doLayout(ConstraintSpace space, ChildBreakToken breakToken);
};

interface InlineLayoutChild : LayoutChild {
};

interface BoxLayoutChild : LayoutChild {
    readonly attribute StylePropertyMapReadOnly styleMap;
};
</pre>

A {{LayoutChild}} represents either a CSS generated <a>box</a> or a sequence of <a>inline boxes</a>
before layout has occurred. (The box or boxes will all have a computed value of 'display' that is
not ''none'').

The {{LayoutChild}} does not contain any layout information itself (like inline or block size) but
can be used to generate {{Fragment}}s which do contain layout information.

An author cannot construct a {{LayoutChild}} with this API, this happens at a separate stage of the
rendering engine (post style resolution).

A {{InlineLayoutChild}} represents a sequence of non-<a>atomic inlines</a>. It does not have a
single <a>computed style</a> associated with it as it may contain multiple inline boxes inside it.

<div class="note">
    NOTE: As an example the following would be placed into a single {{InlineLayoutChild}}:
    <pre class="lang-html">
        This is a next node, &lt;span>with some additional styling,
        that may&lt;/span> break over&lt;br>multiple lines.
    </pre>
</div>

Multiple non-<a>atomic inlines</a> are placed within the same {{InlineLayoutChild}} to allow
rendering engines to perform text shaping across element boundaries.

<div class="note">
    NOTE: As an example the following should produce one {{Fragment}} but is from
    three non-<a>atomic inlines</a>:
    <pre class="lang-html">
        &#x639;&lt;span style="color: blue">&#x639;&lt;/span>&#x639;
    </pre>
</div>

NOTE: In a future level of the specification there may be a way to query the <a>computed style</a>
      of ranges inside a {{InlineLayoutChild}}.

A {{BoxLayoutChild}} represents a single <a>box</a>. It does have an associated computed style which
can be asscessed by {{BoxLayoutChild/styleMap}}. The {{BoxLayoutChild/styleMap}} will only contain
properties which are listed in the <a>child input properties</a> array.

A {{BoxLayoutChild}} could be generated by:

 - An <a>element</a>.

 - A <a>::before</a> or <a>::after</a> pseudo-element.

    NOTE: Other pseudo-elements such as <a>::first-letter</a> or <a>::first-line</a> do not generate
        a box for layout purposes. They are additional styling information for a text node.

 - An anonymous box. For example an anonymous box may be inserted as a result of:

    - A <a>Text</a> node which has undergone <a>blockification</a>. (Or more generally a
        {{InlineLayoutChild}} which has undergone <a>blockification</a>).

    - An element with ''display: table-cell'' which doesn't have a parent with ''display: table''.

 - An <a>atomic inline</a>.

<div class="note">
    NOTE: As an example the following would be placed into three {{BoxLayoutChild}}ren:
    <pre class="lang-html">
        &lt;style>
          #box::before { content: 'hello!'; }
        &lt;/style>
        <!-- A ::before pseudo-element is inserted here. -->
        &lt;div id="box">A block level box with text.&lt;/div>
        &lt;img src="..." />
    </pre>
</div>

An array of {{LayoutChild}}ren is passed into the <a>layout method</a> which represents the children
of the current box which is being laid out.

To perform layout on a box the author can invoke the {{LayoutChild/doLayout()}} method. This will
produce a {{Fragment}} which contains layout information.

The {{LayoutChild/doLayout()}} method may be invoked multiple times with different arguments to
query the {{LayoutChild}} for different layout information.

Layout Fragments {#layout-fragments}
------------------------------------

<pre class='idl'>
interface Fragment {
    readonly attribute double inlineSize;
    readonly attribute double blockSize;

    readonly attribute double inlineOverflowSize;
    readonly attribute double blockOverflowSize;

    attribute double inlineOffset;
    attribute double blockOffset;

    readonly attribute ChildBreakToken? breakToken;

    readonly attribute double dominantBaseline;
};
</pre>

A {{Fragment}} represents a CSS <a>fragment</a> of a {{LayoutChild}} after layout has occurred on
that child. This is produced by the {{LayoutChild/doLayout()}} method.

The {{Fragment}} has {{Fragment/inlineSize}} and {{Fragment/blockSize}} attributes, which are set by
the respective child's layout algorithm. They cannot be changed. If the <a>current layout</a>
requires a different {{Fragment/inlineSize}} or {{Fragment/blockSize}} the author must perform
{{LayoutChild/doLayout()}} again with different arguments in order to get different results.

The {{Fragment}} has {{Fragment/inlineOverflowSize}} and {{Fragment/blockOverflowSize}} attributes.
This is the size of the overflow area of the fragment. If the fragment didn't overflow these
attributes will be the same as {{Fragment/inlineSize}} and {{Fragment/blockSize}} respectively.

The author inside the current layout can position a resulting {{Fragment}} by setting its
{{Fragment/inlineOffset}} and {{Fragment/blockOffset}} attributes. If not set by the author they
default to zero.

<div class="example">
The layout algorithm performs a block-like layout (positioning fragments sequentically in the block
direction), while centering its children in the inline direction.

<pre class="lang-javascript">
registerLayout('block-like', class extends Layout {
    static blockifyChildren = true;
    static inputProperties = super.inputProperties;

    *layout(space, children, styleMap) {
        const inlineSize = resolveInlineSize(space, styleMap);

        const bordersAndPadding = resolveBordersAndPadding(constraintSpace, styleMap);
        const scrollbarSize = resolveScrollbarSize(constraintSpace, styleMap);
        const availableInlineSize = inlineSize -
                                    bordersAndPadding.inlineStart -
                                    bordersAndPadding.inlineEnd -
                                    scrollbarSize.inline;

        const availableBlockSize = resolveBlockSize(constraintSpace, styleMap) -
                                   bordersAndPadding.blockStart -
                                   bordersAndPadding.blockEnd -
                                   scrollbarSize.block;

        const childFragments = [];
        const childConstraintSpace = new ConstraintSpace({
            inlineSize: availableInlineSize,
            blockSize: availableBlockSize,
        });

        let maxChildInlineSize = 0;
        let blockOffset = bordersAndPadding.blockStart;

        for (let child of children) {
            const fragment = yield child.doLayout(childConstraintSpace);

            // Position the fragment in a block like manner, centering it in the
            // inline direction.
            fragment.blockOffset = blockOffset;
            fragment.inlineOffset = Math.max(
                bordersAndPadding.inlineStart,
                (availableInlineSize - fragment.inlineSize) / 2);

            maxChildInlineSize =
                Math.max(maxChildInlineSize, childFragments.inlineSize);
            blockOffset += fragment.blockSize;
        }

        const inlineOverflowSize = maxChildInlineSize + bordersAndPadding.inlineEnd;
        const blockOverflowSize = blockOffset + bordersAndPadding.blockEnd;
        const blockSize = resolveBlockSize(constraintSpace, styleMap, blockOverflowSize);

        return {
            inlineSize: inlineSize,
            blockSize: blockSize,
            inlineOverflowSize: inlineOverflowSize,
            blockOverflowSize: blockOverflowSize,
            childFragments: childFragments,
        };
    }
});
</pre>
</div>

The {{Fragment}}'s {{Fragment/breakToken}} specifies where the {{LayoutChild}} last fragmented. If
the {{Fragment/breakToken}} is null the {{LayoutChild}} wont produce any more {{Fragment}}s for that
token chain. The {{Fragment/breakToken}} can be passed to the {{LayoutChild/doLayout()}} function to
produce the next {{Fragment}} for a particular child. The {{Fragment/breakToken}} cannot be changed.
If the <a>current layout</a> requires a different {{Fragment/breakToken}} the author must perform
{{LayoutChild/doLayout()}} again with different arguments.

The {{Fragment}}'s {{Fragment/dominantBaseline}} attribute specify where the dominant baseline is
positioned relative to the block start of the fragment. It cannot be changed.

NOTE: In a future level of the specification there may be a way to query for additional baseline
      information, for example where the alphabetic or center baseline is positioned.

Constraint Spaces {#constraint-spaces}
--------------------------------------

<pre class='idl'>
[
    Constructor(optional ConstraintSpaceOptions options)
]
interface ConstraintSpace {
    readonly attribute double inlineSize;
    readonly attribute double blockSize;

    readonly attribute boolean inlineSizeFixed;
    readonly attribute boolean blockSizeFixed;

    readonly attribute boolean inlineShrinkToFit;

    readonly attribute double percentageInlineSize;
    readonly attribute double percentageBlockSize;

    readonly attribute BlockFragmentationType blockFragmentationType;
};

dictionary ConstraintSpaceOptions {
    double inlineSize = Infinity;
    double blockSize = Infinity;

    boolean inlineSizeFixed = false;
    boolean blockSizeFixed = false;

    boolean inlineShrinkToFit = false;

    double? percentageInlineSize = null;
    double? percentageBlockSize = null;

    BlockFragmentationType blockFragmentationType = "none";
};

enum BlockFragmentationType { "none", "page", "column", "region" };
</pre>

A {{ConstraintSpace}} is passed into the <a>layout method</a> which represents the available space
for the <a>current layout</a> to perform layout inside. It is also used to pass information about
the available space into a <a>child layout</a>.

The {{ConstraintSpace}} has {{ConstraintSpace/inlineSize}} and {{ConstraintSpace/blockSize}}
attributes. This represents the <a>available space</a> for a {{Fragment}} which the layout should
respect.

NOTE: Some layouts may need to produce a {{Fragment}} which exceed this size. For example a
    <a>replaced element</a>. The <a>parent layout</a> should expect this to occur and deal with it
    appropriately.

A <a>parent layout</a> may require the <a>current layout</a> to be exactly a particular size. If
the {{ConstraintSpace/inlineSizeFixed}} or {{ConstraintSpace/blockSizeFixed}} are true the
<a>current layout</a> should produce a {{Fragment}} with a fixed size in the appropriate direction.

<div class="example">
The layout algorithm performs a flexbox-like distribution of spare space in the inline direction. It
creates child constraint spaces which specify that a child should be a fixed inline size.

<pre class="lang-javascript">
registerLayout('flex-distribution-like', class {
    *layout(space, children, styleMap, breakToken) {
        const inlineSize = resolveInlineSize(space, styleMap);

        const bordersAndPadding = resolveBordersAndPadding(constraintSpace, styleMap);
        const scrollbarSize = resolveScrollbarSize(constraintSpace, styleMap);
        const availableInlineSize = inlineSize -
                                    bordersAndPadding.inlineStart -
                                    bordersAndPadding.inlineEnd -
                                    scrollbarSize.inline;

        const availableBlockSize = resolveBlockSize(constraintSpace, styleMap) -
                                   bordersAndPadding.blockStart -
                                   bordersAndPadding.blockEnd -
                                   scrollbarSize.block;

        const unconstrainedSizes = [];
        const childConstraintSpace = new ConstraintSpace({
            inlineShrinkToFit: true,
            inlineSize: availableInlineSize,
            blockSize: availableBlockSize,
        });
        let totalSize = 0;

        // Calculate the unconstrained size for each child.
        for (let child of children) {
            const fragment = yield child.doLayout(childConstraintSpace);
            unconstrainedSizes.push(fragment.inlineSize);
            totalSize += fragment.inlineSize;
        }

        // Distribute spare space between children.
        const remainingSpace = Math.max(0, inlineSize - totalSize);
        const extraSpace = remainingSpace / children.length;
        const childFragments = [];
        let inlineOffset = 0;
        let maxChildBlockSize = 0;
        for (let i = 0; i < children.length; i++) {
            let fragment = yield child.doLayout(new ConstraintSpace({
                inlineSize: unconstrainedSizes[i] + extraSpace,
                inlineSizeFixed: true,
                blockSize: availableBlockSize
            }));

            fragment.inlineOffset = inlineOffset;
            inlineOffset += fragment.inlineSize;

            maxChildBlockSize = Math.max(maxChildBlockSize, fragment.blockSize);

            childFragments.push(fragment);
        }

        // Resolve our block size.
        const blockSize = resolveBlockSize(constraintSpace, styleMap, maxChildBlockSize);

        return {
            inlineSize: inlineSize,
            blockSize: blockSize,
            inlineOverflowSize: Math.max(inlineSize, totalSize),
            blockOverflowSize: maxChildBlockSize,
            childFragments: childFragments,
        };
    }
});
</pre>
</div>

The {{ConstraintSpace}} has a {{ConstraintSpace/inlineShrinkToFit}} attribute. This is used to
indicate that the layout should treat ''auto'' as ''fit-content'' instead.

The {{ConstraintSpace}} has {{ConstraintSpace/percentageInlineSize}} and
{{ConstraintSpace/percentageBlockSize}} attributes. These represent the size that a layout
percentages should be resolved against while performing layout.

The {{ConstraintSpace}} has a {{ConstraintSpace/blockFragmentationType}} attribute. The <a>current
layout</a> should produce a {{Fragment}} which fragments at the {{ConstraintSpace/blockSize}} if
possible. 

The <a>current layout</a> may choose not to fragment a {{LayoutChild}} based on the
{{ConstraintSpace/blockFragmentationType}}, for example if the child has a property like
''break-inside: avoid-page;''.

Breaking and Fragmentation {#breaking-and-fragmentation}
--------------------------------------------------------

<pre class="idl">
interface ChildBreakToken {
    readonly attribute BreakType breakType;
    readonly attribute Box box;
};

interface BreakToken {
    readonly attribute sequence&lt;ChildBreakToken> childBreakTokens;
    readonly attribute Object data;
};

dictionary BreakTokenOptions {
    sequence&lt;ChildBreakToken> childBreakTokens;
    Object data = null;
};

enum BreakType { "none", "inline", "inline-hyphen", "column", "page", "region" };
</pre>

Issue(w3c/css-houdini-drafts#258): What type of {{BreakType}}s are needed?

A {{LayoutChild}} can produce multiple {{Fragment}}s. A {{BoxLayoutChild}} may fragment in the block
direction if a {{ConstraintSpace/blockFragmentation}} is not none. A {{InlineLayoutChild}} may
fragment in the inline direction.

A subsequent {{Fragment}} is produced by using the previous {{Fragment}}'s {{Fragment/breakToken}}.
This tells the <a>child layout</a> to produce a {{Fragment}} starting at the point encoded in the
{{ChildBreakToken}}.

When returning a list of {{Fragment}}s from the <a>current layout</a> the list of {{Fragment}}s must
have a contiguous set of {{Fragment/breakToken}}s.

<div class="example">
TODO: add example showing non-contiguous set of fragments.
</div>

<div class="example">
This example shows how to use a previous {{Fragment}}'s {{Fragment/breakToken}} to produce the next
{{Fragment}} in the sequence.

<pre class="lang-javascript">
registerLayout('fragmenting', class {
    *layout(space, children, styleMap, breakToken) {

      // ... snip ...

      const fragments = [];
      let breakToken = null;
      for (let child of children) {
          // This do-while loop will keep producing fragments for a child box
          // until it cannot produce any more.
          do {
              // ... snip ... (setting up child constraint space).

              let fragment = yield child.doLayout(childSpace, breakToken);
              breakToken = fragment.breakToken;

              fragments.push(fragment);
          } while (breakToken);
      }

      // ... snip ...

    }
});
</pre>
</div>

<div class="example">
This example shows how to use resume a layout given a breakToken.

<pre class="lang-javascript">
registerLayout('fragmenting', class {
    *layout(space, children, styleMap, breakToken) {
        const fragments = [];

        // Produce the next fragment in the sequence if we have a breakToken.
        if (breakToken) {
            for (let childBreakToken of breakToken.childBreakTokens) {
                let fragment = yield childBreakToken.box.doLayout(
                        childSpace, childBreakToken);

                fragments.push(fragment);
            }
        }
    }
});
</pre>
</div>

Layout Invalidation {#layout-invalidation}
==========================================

A <a>document</a> has an associated <dfn>layout name to input properties map</dfn> and a <dfn>layout
name to child input properties map</dfn>. Initialy these maps are empty and are populated when
{{registerLayout(name, layoutCtor)}} is called.

Each <a>box</a> has an associated <dfn>layout valid flag</dfn>. It may be either
<dfn>layout-valid</dfn> or <dfn>layout-invalid</dfn>. It is initially set to <a>layout-invalid</a>.

When the computed style for a |box| changes, the user agent must run the following steps:
    1. Let |layoutFunction| be the <<layout()>> or <<inline-layout()>> function of the 'display'
        property on the computed style if it exists. If it is a different type of value (e.g.
        ''grid'') then abort all these steps.

    2. Let |name| be the first argument of the |layoutFunction|.

    3. Let |inputProperties| be the result of looking up |name| on <a>layout name to input
        properties map</a>.

    4. Let |childInputProperties| be the result of looking up |name| on <a>layout name to child
        input properties map<a>.

    5. For each |property| in |inputProperties|, if the |property|'s <a>computed value</a> has
        changed, set the <a>layout valid flag</a> on the <a>box</a> to <a>layout-invalid</a>.

    6. For each |property| in |childInputProperties|, if the |property|'s <a>computed value</a> has
        changed, set the <a>layout valid flag</a> on the <a>box</a> to <a>layout-invalid</a>.

When a child <a>box</a> represented by a {{BoxLayoutChild}} is added or removed from the <a>box
tree</a> or has its layout invalidated (from a computed style change). Set the <a>layout valid
flag</a> on the current <a>box</a> to <a>layout-invalid</a>.

When a child non-<a>atomic inline</a> represented by a {{InlineLayoutChild}} is added or removed
from the <a>box tree</a> or has its layout invalidated (from a computed style change, or if its text
has changed). Set the <a>layout valid flag</a> on the current <a>box</a> to <a>layout-invalid</a>.

NOTE: This only describes layout invalidatation as it relates to the CSS Layout API. All
    <a>boxes</a> conceptually have a <a>layout valid flag</a> and these changes are propogated
    through the <a>box tree</a>.

Layout Engine {#layout-engine}
==============================

<pre class="idl">
interface FragmentRequestToken {
  // Has internal slots:
  // [[layoutChild]] - The layout child to generate the fragment for.
  // [[constraintSpace]] - The constraint space to perform layout in.
  // [[breakToken]] - The break token to resume the layout with.
};
</pre>

The layout method on the author supplied layout class is a generator function instead of a regular
javascript function. This is for user-agents to be able to support asyncronous and parallel layout
engines.

When an author invokes the {{LayoutChild/doLayout()}} method on a {{LayoutChild}} the user-agent
doesn't synchronously generate a {{Fragment}} to return to the author's code. Instead it returns a
{{FragmentRequestToken}}. This is a completely opaque object to the author but contains internal
slots which encapsulates the {{Box/doLayout()}} method call.

When a {{FragmentRequestToken}}(s) are yielded from a layout generator object the user-agent's
layout engine may run the algorithm asynchronously with other work, and/or on a different thread of
execution. When {{Fragment}}(s) have been produced by the engine, the user-agent will 'tick' the
generator object with the resulting {{Fragment}}(s).

Issue: Write algorithm "<dfn>generate a fragment</dfn>" which encapsulates this.

<div class="example">
An example layout engine written in javascript is shown below.

<pre class="lang-javascript">
class LayoutEngine {
  // This function takes the root of the box-tree, a ConstraintSpace, and a
  // BreakToken to (if paginating for printing for example) and generates a
  // Fragment.
  layoutEntry(rootBox, rootPageConstraintSpace, breakToken) {
    return layoutFragment({
      box: rootBox,
      constraintSpace: rootPageConstraintSpace,
      breakToken: breakToken,
    });
  }

  // This function takes a FragmentRequestToken and calls the appropriate layout
  // algorithm to generate the a Fragment.
  layoutFragment(fragmentRequest) {
    const box = fragmentRequest.box;
    const algorithm = selectLayoutAlgorithmForBox(box);
    const fragmentRequestGenerator = algorithm.layout(
        fragmentRequest.constraintSpace,
        box.children,
        box.styleMap,
        fragmentRequest.breakToken);

    let nextFragmentRequest = fragmentRequestGenerator.next();

    while (!nextFragmentRequest.done) {
      // A user-agent may decide to perform layout to generate the fragments in
      // parallel on separate threads. This example performs them synchronously
      // in order.
      let fragments = nextFragmentRequest.value.map(layoutFragment);

      // A user-agent may decide to yield for other work (garbage collection for
      // example) before resuming this layout work. This example just performs
      // layout synchronously without any ability to yield.
      nextFragmentRequest = fragmentRequestGenerator.next(fragments);
    }

    return nextFragmentRequest.value; // Return the final Fragment.
  }
}
</pre>
</div>

TODO explain parallel layout + {{FragmentRequestToken}}, etc.

Registering A Layout {#registering-a-layout}
============================================

<pre class='idl'>
partial interface LayoutWorkletGlobalScope {
    void registerLayout(DOMString name, VoidFunction layoutCtor);
};
</pre>

The {{LayoutWorkletGlobalScope}} has a map of <b>name to layout constructor map</b>. Initially this
map is empty; it is populated when {{registerLayout(name, layoutCtor)}} is called.

Issue: Write full register algorithm, and checks required.

<div class='note'>
    This is what the shape of the class should be:
    <pre class='idl'>
        callback interface LayoutClass {
            readonly attribute sequence&lt;DOMString> inputProperties;
            readonly attribute sequence&lt;DOMString> childInputProperties;

            LayoutResult layout(
                    ConstraintSpace space,
                    sequence&lt;Box> children,
                    StylePropertyMap styleMap,
                    BreakToken break);
        };
    </pre>
</div>

Layout Notation {#layout-notation}
==================================

<pre class='prod'>
    <dfn>layout()</dfn> = layout( <<ident>> )
    <dfn>inline-layout()</dfn> = inline-layout( <<ident>> )
</pre>

The <<layout()>> and <<inline-layout()>> function is an additional notation to be supported by the
'display' property.

Issue: Resolve this with css-display-3 once required.

Layout {#layout}
================

Performing layout {#performing-layout}
--------------------------------------

<pre class='idl'>
dictionary LayoutResult {
    double inlineSize;
    double blockSize;
    sequence&lt;Fragment> fragments;
    BreakToken breakToken;
    double baseline;
};
</pre>

{{LayoutClass/layout()}} is invoked by the user agent when <a>generate a layout</a> for a <a>box</a>.

The user agent passes in:
  - The current children for the <a>box</a>, with only {{LayoutClass/childInputProperties}} on
    {{Box/styleMap}}
  - The available space defined by a {{ConstraintSpace}}
  - The computed style of the <a>box</a>, with only {{LayoutClass/inputProperties}}
  - The {{BreakToken}} if any, for where the <a>box</a> was last fragmented.

The author defined code should produce a {{LayoutResult}}.

The {{LayoutResult}} consists of:
 - A {{LayoutResult/minContent}} which represents the fragment's <a>min-content inline-size
    contribution</a>.
 - A {{LayoutResult/maxContent}} which represents the fragment's <a>max-content inline-size
    contribution</a>.
 - A {{LayoutResult/width}} which represents the fragment's resulting width.
 - A {{LayoutResult/height}} which represents the fragment's resulting height.
 - A list of {{LayoutResult/fragments}} which represents the fragment's direct child fragments.
 - A list of {{LayoutResult/unpositionedFragments}} which represents the fragment's children which
    should be positioned by a parent fragment.
 - A {{LayoutResult/breakToken}} which represents where the current layout's box last broke.
 - A {{LayoutResult/baseline}} which represents the baseline of the fragment.

Issue: Write the following into the algorithm.

If any {{Fragment}}s appear in both the list of {{LayoutResult/fragments}} or the list of
{{LayoutResult/unpositionedFragments}} the user agent should throw an error.

The user agent should check that a consistent set of {{Fragment}}s generated from a {{LayoutChild}}
is returned in either the list of {{LayoutResult/fragments}} or
{{LayoutResult/unpositionedFragments}}. (Consistent being that a {{Fragment/breakToken}} from one
{{Fragment}} was used to generate another {{Fragment}} in the set).

If any {{Fragment}}s appear more than once, the user agent should throw an error.

When the user agent wants to <dfn>generate a layout</dfn> of a <<layout()>> or <<inline-layout()>>
for a box it <em>must</em> run the following steps:

Issue: TODO specify these steps.

Examples {#examples}
====================

Example 1: A simple block layout {#example-1}
---------------------------------------------

<pre class='lang-javascript'>
// Inside LayoutWorkletGlobalScope

// Note this is meant to be similar (*not* the same) as a block layout.
// Everything is done in 'width' & 'height' for easy reading.
registerLayout('simple-flow', class {
    static get inputProperties() { return ['width', 'height'] }
    static get childrenInputProperties() { return ['x', 'y', 'position'] }

    layout(children, constraintSpace, styleMap, breakToken) {
        const absoluteChildren = [];
        const fixedChildren = [];
        const fragments = [];

        // Resolve our width using the available width in 'constraintSpace', and
        // our computed width property.
        let width = resolveWidth(constraintSpace, styleMap.get('width'));

        // Create a new constraint space for our children to consume.
        let childConstraintSpace = new ConstraintSpace(constraintSpace);
        childConstraintSpace.width = width;

        // Track the used height, min and max content.
        let height = 0;
        let minContent = 0;
        let maxContent = 0;

        for (let child of children) {
            // Check if the child is out of flow positioned.
            const childPosition = child.styleMap.get('position');

            if (childPosition == 'absolute') {
                absoluteChildren.push(child);
                continue;
            }

            if (childPosition == 'fixed') {
                fixedChildren.push(child);
                continue;
            }

            // Layout the in flow child.
            const childFragment = child.doLayout(childConstraintSpace);

            // Position the child.
            childFragment.x = 0;
            childFragment.y = height;

            // Update our current height, min and max content.
            height += childFragment.height;
            minContent = Math.max(childFragment.minContent, minContent);
            maxContent = Math.max(childFragment.maxContent, maxContent);
        }

        // Resolve the height.
        height = resolveHeight(constraintSpace, styleMap.get('height'), height);

        return {
            minContent: minContent,
            maxContent: maxContent,
            width: width,
            height: height,
            fragments: fragments,
            unPositionedChildren: absoluteChildren.concat(fixedChildren),
            breakToken: null
        };
    }
});
</pre>

<pre class='lang-markup'>
&lt;div id="myElement"&gt;
    &lt;div&gt;
        CSS is awesome.
    &lt;/div&gt;
&lt;/div&gt;

&lt;style&gt;
#myElement {
    display: layout('simple-flow');
}
&lt;/style&gt;
</pre>

Example 2: A simple line layout {#example-2}
--------------------------------------------

<pre class='lang-javascript'>
// Inside LayoutWorkletGlobalScope

// Note this is meant to be similar (*not* the same) as a inline layout.
// Everything is done in 'width' & 'height' for easy reading.
registerLayout('simple-inline-flow', class {
    static get inputProperties() { return ['width', 'height'] }
    static get childrenInputProperties() { return [] }

    layout(children, constraintSpace, styleMap, breakToken) {
        // Resolve our width using the available width in 'constraintSpace', and
        // our computed width property.
        const width = resolveWidth(constraintSpace, styleMap.get('width'));
        const fragments = [];
        let height = 0;

        // TODO compute these.
        let minContent = 0;
        let maxContent = 0;

        let childFragment = null;
        let lineFragments = [];
        let lineHeight = 0;
        let remainingLineWidth = width; // NOTE: should be helper on constraint space?

        const childIter = chidlren.values();
        let child = childIter.next().value;
        let breakToken = null;

        while (child) {
            // Create a new constraint space for the child, with all the current
            // positioned children.
            const childConstraintSpace = new ConstraintSpace(constraintSpace);
            childConstraintSpace.addExclusion(new ExclusionRect(width, height, 0, 0));
            childConstraintSpace.addExclusions(lineFragments);

            // Perform layout on the child.
            childFragment = child.doLayout(childConstraintSpace, breakToken);
            fragments.push(childFragment);

            // Check if we need to position the fragment on the next line.
            if (childFragment.width > remainingLineWidth) {
                // Need to start a new line.
                lineFragments = [];
                height += lineHeight;
                lineHeight = 0;
                remainingLineWidth = width;
            }

            // Position the fragment horizontally.
            childFragment.x = width - remainingLineWidth;

            lineFragments.push(childFragment);
            lineHeight = Math.max(lineHeight, childFragment.height);
            remainingLineWidth -= childFragment.width;

            // Update the line fragments positions, based on the new lineHeight.
            for (let frag of lineFragments) {
                frag.y = lineHeight - frag.height;
            }

            // Step to the next child if required.
            if (childFragment.breakToken) {
                breakToken = childFragment.breakToken;
            } else {
                child = childIter.next().value;
                breakToken = null;
            }
        }

        // Resolve the height.
        height = resolveHeight(constraintSpace, styleMap.get('height'), height);

        return {
            minContent: minContent,
            maxContent: maxContent,
            width: width,
            height: height,
            fragments: fragments,
            unpositionedFragments: [],
            breakToken: null
        };
    }
});
</pre>
