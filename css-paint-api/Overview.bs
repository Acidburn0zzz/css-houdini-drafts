<pre class='metadata'>
Title:  CSS Painting API Level 1
Status: DREAM
Group: houdini
ED: https://drafts.css-houdini.org/css-paint-api-1/
Shortname: css-paint-api
Level: 1
Abstract: 
Editor: Shane Stephens, shanestephens@google.com
Editor: Ian Kilpatrick, ikilpatrick@chromium.org
Editor: Dean Jackson, dino@apple.com
</pre>

<pre class="link-defaults">
spec:css-break-3; type:dfn; text:fragment
</pre>

<pre class="anchors">
urlPrefix: https://heycam.github.io/webidl/; type: dfn;
    text: NotSupportedError
    urlPrefix: #dfn-;
        text: exception
        text: throw
        url: throw; text: thrown
urlPrefix: https://html.spec.whatwg.org/multipage/scripting.html; type: dfn;
    text: reset the rendering context to its default state
urlPrefix: http://www.ecma-international.org/ecma-262/6.0/#sec-; type: dfn;
    text: Construct
    text: IsArray
    text: IsCallable
    text: IsConstructor
    text: HasProperty
    url: get-o-p; text: Get
</pre>

Introduction {#intro}
=====================

The paint stage of CSS is responsible for painting the background, content and highlight of an element based on that element's geometry (as generated by the layout stage) and computed style.

This specification describes an API which allows developers to paint a part of an element in response to geometry / computed style changes.

Note: In a future version of the spec, support may be added for defining the clip, global alpha, filter on a portion of an element (for example on the background layers).

Paint Invalidation {#paint-invalidation}
========================================

A <a>document</a> has an associated <b>paint name to dependencies map</b>. Initially it is empty and is populated when {{registerPaint(name, paintCtor)}} is called.

Each <<paint()>> function for a fragment has an associated <b>paint valid flag</b>. It may be either <dfn>paint-valid</dfn> or <dfn>paint-invalid</dfn>. It is initially set to <a>paint-invalid</a>.

When the geometry (as determined by layout) of a <var>fragment</var> changes, each <<paint()>> function's <b>paint valid flag</b> should be set to <a>paint-invalid</a>.

When the computed style for an element changes, the user agent must run the following steps:
    1. For each <<paint()>> function on the element, perform the following substeps:
        1. Let <var>name</var> be the first argument of the <<paint()>> function.
        2. Let <var>dependencies</var> be the result of performing a lookup in <b>paint name to dependencies map</b> with |name| as the key.
        3. For each <var>property</var> in |dependencies|, if the |property|'s <a>computed value</a> has changed, set the <b>paint valid flag</b> on the |fragment| to <a>paint-invalid</a>.

[[#drawing-an-image]] results in the <b>paint valid flag</b> for a <<paint()>> function to be set to <a>paint-valid</a>.

Note: In a future version of the spec, support may be added for partial invalidation.
    The user agent will be able to specify a region of the rendering context which needs to be re-painted by the paint class.

Registering Custom Paint {#registering-custom-paint}
====================================================

<pre class='idl'>
callback VoidFunction = void ();

interface PaintProcessorGlobalScope : ProcessorGlobalScope {
    void registerPaint(DOMString name, VoidFunction paintCtor);
    void unregisterPaint(DOMString name);
};
</pre>

A {{PaintProcessorGlobalScope}} has a map of <b>name to paint instance map</b>. Initially this map is empty; it is populated when {{registerPaint(name, paintCtor)}} is called.

When the <dfn method for=PaintProcessorGlobalScope>registerPaint(<var>name</var>, <var>paintCtor</var>)</dfn> method is called, the user agent <em>must</em> run the following steps:
    1. If the |name| is not a valid <<ident>>, <a>throw</a> a <a>NotSupportedError</a> and abort all these steps.
    2. If the |name| exists as a key in the <b>name to paint instance map</b>, <a>throw</a> a <a>NotSupportedError</a> and abort all these steps.
    3. If the result of <a>IsConstructor</a>(argument=|paintCtor|) is false, <a>throw</a> a <a>NotSupportedError</a> and abort all these steps.
    4. Let <var>prototype</var> be the result of <a>Get</a>(O=|paintCtor|, P="prototype").
    5. If the result of <a>IsCallable</a>(argument=<a>Get</a>(O=|prototype|, P="paint")) is false, <a>throw</a> a <a>NotSupportedError</a> and abort all these steps.
    6. If the result of <a>HasProperty</a>(O=|prototype|, P="overflow") and <a>IsCallable</a>(argument=<a>Get</a>(O=|prototype|, P="overflow")) is false, <a>throw</a> a <a>NotSupportedError</a> and abort all these steps.
    7. Let <var>dependencies</var> be the result of <a>Get</a>(O=|paintCtor|, P="dependencies").
    8. If the result of <a>IsArray</a>(argument=|dependencies|) is false, <a>throw</a> a <a>NotSupportedError</a> and abort all these steps.
    9. Add the key-value pair (|name| - |dependencies|) to the <b>paint name to dependencies map</b> of the associated <a>document</a>.
    10. Let <var>paintInstance</var> be the result of <a>Construct</a>(|paintCtor|).
    11. Add the key-value pair (|name| - |paintInstance|) to the <b>name to paint instance map</b> of the {{PaintProcessorGlobalScope}}.

Note: The list of CSS properties provided by the dependencies getter can either be custom or native CSS properties.

Note: The list of dependencies should only be looked up once, the class doesn't have the opportunity to dynamically change its dependencies.

Note: In a future version of the spec, the author may be able to set an option to receive a different type of RenderingContext. In particular the author may want a WebGL based rendering context to render 3D effects.

Issue(w3c/css-houdini-drafts#31): Allow author to specify the intrinsic size.

When the <dfn method for=PaintProcessorGlobalScope>unregisterPaint(<var>name</var>)</dfn> method is called, the user agent <em>must</em> run the following steps:
    1. Remove the key-value pair associated with the |name| key in the <b>paint name to dependencies map</b> of the associated <a>document</a>.
    2. Remove the key-value pair associated with the |name| key in the <b>name to paint instance map</b> of the {{PaintProcessorGlobalScope}}.

Paint Notation {#paint-notation}
================================

<pre class='prod'>
    <dfn>paint()</dfn> = paint( <<ident>> )
</pre>

The <<paint()>> function is an additional notation to be supported by the <<image>> type.

<div class="example">
    <pre>background-image: paint(my_logo);</pre>
</div>

Issue(w3c/css-houdini-drafts#33): What to do about cursor.

Issue: How do we do things like conic-gradient? I.e. paint functions which accept arguments as inputs?

Drawing an image {#drawing-an-image}
====================================

<pre class='idl'>
interface PaintRenderingContext2d {
    // TODO link to actual CanvasRenderingContext2d.
};

interface Geometry {
    readonly attribute double width;
    readonly attribute double height;
};
</pre>

Issue: Create a new interface which uses IDL mixins to share methods with CanvasRenderingContext2d.

When the user agent wants to draw an image of a <<paint()>> for a <var>fragment</var> into its appropriate stacking level (as defined by the property the CSS property it's associated with) it <em>must</em> run the following steps:
    1. If the <b>paint valid flag</b> for the <<paint()>> function on the |fragment| is <a>paint-valid</a> the user agent <em>may</em> use the drawn image from the previous invocation.
        If so it can abort all these steps.

        Note: The user agent for implementation reasons may also continue with all these steps in this case. It can do this every frame, or multiple times per frame.

    2. Let <var>name</var> be the first argument of the <<paint()>> function.

    3. If no paint class was registered with |name|, the resulting image output will be an <a>invalid image</a> and the user agent must abort all these steps.

    4. Let <var>dependencies</var> be the result of looking up |name| on the associated <a>document</a>'s <b>paint name to dependencies map</b>.

    5. Let <var>styleMap</var> be a new {{StylePropertyMap}} populated with <em>only</em> the <a>computed value</a>'s for properties listed in |dependencies|.

    6. Let <var>overflow</var> be the result <a>invoke a method on a class inside a Processor</a> given "overflow" as the <em>methodPropertyKey</em> and [|styleMap|] as the <em>arguments</em> with the following options:
        - To <a>create a processor global scope</a> the user agent will:

            Return a new {{PaintProcessorGlobalScope}}.
        - To <a>lookup a class instance on a processor global scope</a> given a |processorGlobalScope|, the user agent will:

            Return the result of looking up |name| on the |processorGlobalScope|'s <b>name to paint instance map</b>.

        Note: User agents may have to compute overflow before entering their paint phase in order to determine which fragments to paint (overflow changes what could be seen on the output device).
            User agents may opt into running the steps up to this point, to determine overflow, then continuing later to determine the drawn image for the fragments which need painting.

    7. Let <var>renderingContext</var> be a new {{PaintRenderingContext2d}}.

        The backing size of the |renderingContext| must be the size of the |fragment| plus the size specified by |overflow|.

        The user agent must ensure to <a>reset the rendering context to its default state</a>.

        The origin of the |renderingContext| must be offset by the left, top size specified by |overflow|.

        Note: (0,0) is the top-left of the |fragment|, (-offsetLeft,-offsetTop) is the top-left of the |overflow|.

        Note: The |renderingContext| must not be re-used between invocations of paint. Implicitly this means that there is no stored data, or state on the |renderingContext| between invocations.
            For example you can't setup a clip on the context, and expect the same clip to be applied next time the paint method is called.

        Issue: TODO add note we should specify the output of overflow.

    8. Let <var>geometry</var> be a new {{Geometry}} initialized to the width and height of the |fragment|.

        Issue(w3c/css-houdini-drafts#23): Decide geometry information should be in level 1.

    9. To produce the image output, <a>invoke a method on a class inside a Processor</a> given "paint" as the <em>methodPropertyKey</em> and [|renderingContext|, |geometry|, |styleMap|] as the <em>arguments</em> with the following options:
        - To <a>create a processor global scope</a> the user agent will:

            Return a new {{PaintProcessorGlobalScope}}.
        - To <a>lookup a class instance on a processor global scope</a> given a |processorGlobalScope|, the user agent will:

            Return the result of looking up |name| on the |processorGlobalScope|'s <b>name to paint instance map</b>.

        If an exception is <a>thrown</a> the resulting image output will be an <a>invalid image</a>.

        Otherwise the image output should be produced from the |renderingContext| given to the paint method.

        Note: User agents should provide tooling within their debugging tools to show authors a partial output of the image, if an exception is thrown.

    10. Set the <b>paint valid flag</b> for the <<paint()>> function on the |fragment| to <a>paint-valid</a>.

Note: The user agent should consider long running paint functions similar to long running script in the main execution context.
    For example, they should how a "unresponsive script" dialog or similar.

Note: The user agent doesn't have produce the image output for a <<paint()>> function on the current frame if it's <b>paint valid flag</b> is <a>paint-invalid</a>.
    For example the fragment may be outside the visible viewport, and not required for display on the output device. 

Issue(w3c/css-houdini-drafts#24): Determine how to side-load images or other data.

Issue: What information should we provide for read-modify-write use-cases?
       Are read-modify-write use-cases important for v1?
       For example, if you are sliding the previous paint output out?
       For providing the previous paint output we should provide an ImageBitmap if you ask.

Issue: Describe what happens if a callback doesn't hit a frame timing boundary. I.e. just renders a transparent image instead?

Examples {#examples}
====================

Example 1: A colored circle. {#example-1}
-----------------------------------------

<pre class='lang-javascript'>
// Inside PaintProcessorGlobalScope.
registerPaint('circle', class {
    static get dependencies() { return ['--circle-color']; }
    paint(ctx, geom, properties) {
        // Change the fill color.
        var color = properties.get('--circle-color');
        ctx.fillStyle = color;

        // Determine the center point and radius.
        var x = geom.width / 2;
        var y = geom.height / 2;
        var radius = Math.min(x, y);

        // Draw the circle \o/
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, 2 * Math.PI, false);
        ctx.fill();
    }
});
</pre>

<pre class='lang-markup'>
&lt;div id="myElement"&gt;
    CSS is awesome.
&lt;/div&gt;

&lt;style&gt;
#myElement {
    --circle-color: red;
    background-image: paint(circle);
}
&lt;/style&gt;
</pre>

Issue: Add conic-gradient as a use case.

Issue: Add image with placeholder as a use case. E.g. mountainy-thingy.

Issue: Add image url with var() input to custom paint as a use case.
