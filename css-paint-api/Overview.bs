<pre class='metadata'>
Title:  CSS Painting API Level 1
Status: DREAM
Group: houdini
ED: https://drafts.css-houdini.org/css-paint-api-1/
Shortname: css-paint-api
Level: 1
Abstract: 
Editor: Shane Stephens, shanestephens@google.com
Editor: Ian Kilpatrick, ikilpatrick@chromium.org
Editor: Dean Jackson, dino@apple.com
</pre>

<pre class="link-defaults">
spec:css-break-3; type:dfn; text:fragment
</pre>

<pre class="anchors">
urlPrefix: https://heycam.github.io/webidl/; type: dfn;
    text: NotSupportedError
    urlPrefix: #dfn-;
        text: exception
        text: throw
        url: throw; text: thrown
urlPrefix: https://html.spec.whatwg.org/multipage/scripting.html; type: dfn;
    text: reset the rendering context to its default state
    text: scratch bitmap
    text: set bitmap dimensions
urlPrefix: http://www.ecma-international.org/ecma-262/6.0/#sec-; type: dfn;
    text: Construct
    text: IsArray
    text: IsCallable
    text: IsConstructor
    text: HasProperty
    url: get-o-p; text: Get
</pre>

Introduction {#intro}
=====================

The paint stage of CSS is responsible for painting the background, content and highlight of an element based on that element's geometry (as generated by the layout stage) and computed style.

This specification describes an API which allows developers to paint a part of an element in response to geometry / computed style changes.

Note: In a future version of the spec, support may be added for defining the clip, global alpha, filter on a portion of an element (for example on the background layers).

Paint Invalidation {#paint-invalidation}
========================================

A <a>document</a> has an associated <b>paint name to input properties map</b>. Initially it is empty and is populated when {{registerPaint(name, paintCtor)}} is called.

Each <<paint()>> function for a fragment has an associated <b>paint valid flag</b>. It may be either <dfn>paint-valid</dfn> or <dfn>paint-invalid</dfn>. It is initially set to <a>paint-invalid</a>.

When the geometry (as determined by layout) of a <var>fragment</var> changes, each <<paint()>> function's <b>paint valid flag</b> should be set to <a>paint-invalid</a>.

When the computed style for an element changes, the user agent must run the following steps:
    1. For each <<paint()>> function on the element, perform the following substeps:
        1. Let <var>name</var> be the first argument of the <<paint()>> function.
        2. Let <var>inputProperties</var> be the result of performing a lookup in <b>paint name to input properties map</b> with |name| as the key.
        3. For each <var>property</var> in |inputProperties|, if the |property|'s <a>computed value</a> has changed, set the <b>paint valid flag</b> on the |fragment| to <a>paint-invalid</a>.

[[#drawing-an-image]] results in the <b>paint valid flag</b> for a <<paint()>> function to be set to <a>paint-valid</a>.

Note: In a future version of the spec, support may be added for partial invalidation.
    The user agent will be able to specify a region of the rendering context which needs to be re-painted by the paint class.

Paint Worklet {#paint-worklet}
==============================

The {{paintWorklet}} attribute allows access to the {{Worklet}} responsible for all the classes
which are related to painting.

The {{paintWorklet}}'s <b>worklet global scope type</b> is {{PaintWorkletGlobalScope}}.

<pre class='idl'>
partial interface Window {
    [SameObject] readonly attribute Worklet paintWorklet;
};
</pre>

The {{PaintWorkletGlobalScope}} is the global execution context of the {{paintWorklet}}.

<pre class='idl'>
callback VoidFunction = void ();

interface PaintWorkletGlobalScope : WorkletGlobalScope {
    void registerPaint(DOMString name, VoidFunction paintCtor);
};
</pre>

Registering Custom Paint {#registering-custom-paint}
====================================================

The {{PaintWorkletGlobalScope}} has a map of <b>name to paint instance map</b>. Initially this map is empty; it is populated when {{registerPaint(name, paintCtor)}} is called.

<div class='note'>
    Note: This is how the class should look.
    <pre class='idl'>
        callback interface PaintClass {
            readonly attribute sequence&lt;DOMString&gt; inputProperties;
            void paint(PaintRenderingContext2D ctx, Geometry geom, StylePropertyMap inputProperties);
        };
    </pre>
</div>

When the <dfn method for=PaintWorkletGlobalScope>registerPaint(<var>name</var>, <var>paintCtor</var>)</dfn> method is called, the user agent <em>must</em> run the following steps:
    1. If the |name| is not a valid <<ident>>, <a>throw</a> a <a>NotSupportedError</a> and abort all these steps.
    2. If the |name| exists as a key in the <b>name to paint instance map</b>, <a>throw</a> a <a>NotSupportedError</a> and abort all these steps.
    3. If the result of <a>IsConstructor</a>(argument=|paintCtor|) is false, <a>throw</a> a <a>NotSupportedError</a> and abort all these steps.
    4. Let <var>prototype</var> be the result of <a>Get</a>(O=|paintCtor|, P="prototype").
    5. If the result of <a>IsCallable</a>(argument=<a>Get</a>(O=|prototype|, P="paint")) is false, <a>throw</a> a <a>NotSupportedError</a> and abort all these steps.
    6. Let <var>inputProperties</var> be the result of <a>Get</a>(O=|paintCtor|, P="inputProperties").
    7. If the result of <a>IsArray</a>(argument=|inputProperties|) is false, <a>throw</a> a <a>NotSupportedError</a> and abort all these steps.
    8. Add the key-value pair (|name| - |inputProperties|) to the <b>paint name to input properties map</b> of the associated <a>document</a>.
    9. Let <var>paintInstance</var> be the result of <a>Construct</a>(|paintCtor|).
    10. Add the key-value pair (|name| - |paintInstance|) to the <b>name to paint instance map</b> of the {{PaintWorkletGlobalScope}}.

Note: The list of CSS properties provided by the input properties getter can either be custom or native CSS properties.

Note: The list of input properties should only be looked up once, the class doesn't have the opportunity to dynamically change its input properties.

Note: In a future version of the spec, the author may be able to set an option to receive a different type of RenderingContext.
    In particular the author may want a WebGL rendering context to render 3D effects.
    There are complexities in setting up a WebGL rendering context to take the {{Geometry}} and {{StylePropertyMap}} as inputs.

Issue(w3c/css-houdini-drafts#31): Allow author to specify the intrinsic size.

Paint Notation {#paint-notation}
================================

<pre class='prod'>
    <dfn>paint()</dfn> = paint( <<ident>> )
</pre>

The <<paint()>> function is an additional notation to be supported by the <<image>> type.

<div class="example">
    <pre>background-image: paint(my_logo);</pre>
</div>

For the 'cursor' property, the <<paint()>> function should be treated as an <a>invalid image</a> and
fallback to the next supported <<image>>.

Issue: How do we do things like conic-gradient? I.e. paint functions which accept arguments as inputs?

The 2D rendering context {#2d-rendering-context}
================================================

<pre class='idl'>
[Exposed=Worklet]
interface PaintRenderingContext2D {
};
PaintRenderingContext2D implements CanvasState;
PaintRenderingContext2D implements CanvasTransform;
PaintRenderingContext2D implements CanvasCompositing;
PaintRenderingContext2D implements CanvasImageSmoothing;
PaintRenderingContext2D implements CanvasFillStrokeStyles;
PaintRenderingContext2D implements CanvasShadowStyles;
PaintRenderingContext2D implements CanvasRect;
PaintRenderingContext2D implements CanvasDrawPath;
PaintRenderingContext2D implements CanvasDrawImage;
PaintRenderingContext2D implements CanvasPathDrawingStyles;
PaintRenderingContext2D implements CanvasPath;
</pre>

Note: The {{PaintRenderingContext2D}} implements a subset of the {{CanvasRenderingContext2D}} API.
    Specifically it doesn't implement the {{CanvasHitRegion}}, {{CanvasImageData}},
    {{CanvasUserInterface}}, {{CanvasText}} or {{CanvasTextDrawingStyles}} APIs.

A {{PaintRenderingContext2D}} object has a <a>scratch bitmap</a>. This is initialised when the
object is created. The size of the <a>scratch bitmap</a> is the size of the fragment it is
rendering.

The size of the <a>scratch bitmap</a> does not necessarily represent the size of the actual bitmap
that the user agent will use internally or during rendering. For example, if the visual viewport is
zoomed the user agent may internally use bitmaps which correspond to the number of device pixels in
the coordinate space, so that the resulting rendering is of high quality.

Additionally the user agent may record the sequence of drawing operations which have been applied to
the <a>scratch bitmap</a> such that the user agent can subsequently draw onto a device bitmap at the
correct resolution. This also allows user agents to re-use the same output of the <a>scratch
bitmap</a> repeatably while the visual viewport is being zoomed for example.

When the user agent is to <dfn>create a PaintRenderingContext2D object</dfn> for a given |width|,
|height| it <em>must</em> run the following steps:
    1. Create a new {{PaintRenderingContext2D}}.
    2. <a>Set bitmap dimensions</a> for the context's <a>scratch bitmap</a> to |width| and |height|.
    3. Return the new {{PaintRenderingContext2D}}.

Drawing an image {#drawing-an-image}
====================================

<pre class='idl'>
[Exposed=Worklet]
interface Geometry {
    readonly attribute double width;
    readonly attribute double height;
};
</pre>

If a <<paint()>> function for a fragment is <a>paint-invalid</a> and the fragment is within the visual viewport,
then user agent <em>must</em> <a>draw an image</a> for the current frame.

Note: The user agent may choose to <a>draw an image</a> for <<paint()>> functions not within the visual viewport.

When the user agent wants to <dfn>draw an image</dfn> of a <<paint()>> for a <var>fragment</var> into its appropriate stacking level (as defined by the property the CSS property it's associated with) it <em>must</em> run the following steps:
    1. If the <b>paint valid flag</b> for the <<paint()>> function on the |fragment| is <a>paint-valid</a> the user agent <em>may</em> use the drawn image from the previous invocation.
        If so it can abort all these steps.

        Note: The user agent for implementation reasons may also continue with all these steps in this case. It can do this every frame, or multiple times per frame.

    2. Let <var>name</var> be the first argument of the <<paint()>> function.

    3. If no paint class was registered with |name|, the resulting image output will be an <a>invalid image</a> and the user agent must abort all these steps.

    4. Let <var>inputProperties</var> be the result of looking up |name| on the associated <a>document</a>'s <b>paint name to input properties map</b>.

    5. Let <var>styleMap</var> be a new {{StylePropertyMap}} populated with <em>only</em> the <a>computed value</a>'s for properties listed in |inputProperties|.

    6. Let <var>renderingContext</var> be the result of <a>create a PaintRenderingContext2D object</a> given:
        - "width" - The width of the |fragment|.
        - "height" - The height of the |fragment|.

        Note: The |renderingContext| must not be re-used between invocations of paint. Implicitly this means that there is no stored data, or state on the |renderingContext| between invocations.
            For example you can't setup a clip on the context, and expect the same clip to be applied next time the paint method is called.

    7. Let <var>geometry</var> be a new {{Geometry}} initialized to the width and height of the |fragment|.

    8. Let |workletGlobalScope| be a {{PaintWorkletGlobalScope}} from the list of <b>worklet's
        WorkletGlobalScopes</b> from the paint {{Worklet}}.

        The user agent <em>may</em> also <a>create a WorkletGlobalScope</a> given the paint
        {{Worklet}} and use that.

        Note: The user agent <em>may</em> use any policy for which {{PaintWorkletGlobalScope}} to
            select or create.

    9. Let |classInstance| be the result of performing a lookup in <b>name to paint instance map</b>
        with |name| as the key.

    10. Perform <a>Invoke</a>(O=|classInstance|, P="paint", Arguments=[|renderingContext|,
            |geometry|, |styleMap|).

    11. The image output should be produced from the |renderingContext| given to the method.

        If an exception is <a>thrown</a> the resulting image output will be an <a>invalid image</a>.

    12. Set the <b>paint valid flag</b> for the <<paint()>> function on the |fragment| to <a>paint-valid</a>.

Note: The user agent should consider long running paint functions similar to long running script in the main execution context.
    For example, they should show a "unresponsive script" dialog or similar.
    In addition user agents should provide tooling within their debugging tools to show authors how expensive their paint classes are.

Note: The contents of the image are not designed to be accessible. Authors should communicate any useful information through the standard accessibility APIs.

Issue(w3c/css-houdini-drafts#24): Determine how to side-load images or other data.

Issue: What information should we provide for read-modify-write use-cases?
       Are read-modify-write use-cases important for v1?
       For example, if you are sliding the previous paint output out?
       For providing the previous paint output we should provide an ImageBitmap if you ask.

Issue: Describe what happens if a callback doesn't hit a frame timing boundary. I.e. just renders a transparent image instead?

Examples {#examples}
====================

Example 1: A colored circle. {#example-1}
-----------------------------------------

<pre class='lang-javascript'>
// Inside PaintWorkletGlobalScope.
registerPaint('circle', class {
    static get inputProperties() { return ['--circle-color']; }
    paint(ctx, geom, properties) {
        // Change the fill color.
        var color = properties.get('--circle-color');
        ctx.fillStyle = color;

        // Determine the center point and radius.
        var x = geom.width / 2;
        var y = geom.height / 2;
        var radius = Math.min(x, y);

        // Draw the circle \o/
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, 2 * Math.PI, false);
        ctx.fill();
    }
});
</pre>

<pre class='lang-markup'>
&lt;div id="myElement"&gt;
    CSS is awesome.
&lt;/div&gt;

&lt;style&gt;
#myElement {
    --circle-color: red;
    background-image: paint(circle);
}
&lt;/style&gt;
</pre>

Issue: Add conic-gradient as a use case.

Issue: Add image with placeholder as a use case. E.g. mountainy-thingy.

Issue: Add image url with var() input to custom paint as a use case.
