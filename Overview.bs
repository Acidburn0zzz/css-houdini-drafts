<pre class='metadata'>
Title:  CSS Animation Worklet API
Status: ED
Group: houdini
ED: https://drafts.css-houdini.org/css-animation-api-1/
Previous Version:
Shortname: css-animation-api
Level: 1
Abstract:
Editor: Majid Valipour, majidvp@google.com

</pre>

<pre class="link-defaults">
spec:css-break-3; type:dfn; text:fragment
</pre>

<pre class="anchors">
urlPrefix: https://heycam.github.io/webidl/; type: dfn;
    text: NotSupportedError
    urlPrefix: #dfn-;
        text: callback this value
        text: exception
        text: throw
        url: throw; text: thrown
    url: es-invoking-callback-functions; text: Invoke
urlPrefix: https://www.w3.org/TR/css3-transitions/#; type: dfn;
    text: animatable properties
urlPrefix: https://www.w3.org/TR/web-animations/#; type: dfn;
    url: the-documents-default-timeline; text: default document timeline
urlPrefix: https://tc39.github.io/ecma262/#sec-; type: dfn;
    text: constructor
    text: Construct
    text: IsCallable
    text: IsConstructor
    text: HasProperty
    url: map-objects; text:map object
    url: get-o-p; text: Get
    url: set-o-p-v-throw; text: Set
    url: terms-and-definitions-function; text: function
    urlPrefix: native-error-types-used-in-this-standard-
        text: TypeError
</pre>

<pre class=biblio>
{
    "explainer": {
        "href": "https://github.com/WICG/animation-worklet/blob/gh-pages/README.md",
        "title": "Animation Worklet Explainer",
        "status": "CR",
        "publisher": "WICG",
        "deliveredBy": [
            "https://github.com/WICG/animation-worklet//"
        ]
    }
}
</pre>

Introduction {#intro}
=====================
This document introduces a new primitive for creating scroll-linked and other high performance 
procedural animations on the web. For details on the rational and motivation see [[explainer]].

The <a>Animation Worklet</a> provides a method to create scripted animations that can mutate a set
of user visible animatable attributes. The API is designed to make it possible such animations to
run in performance critical parts of rendering pipeline. Although the specification does not
require certain performance guarantees (e.g., running in sync with every frame produced or in
isolation from main thread) but the API is designed to facilitate and encourage this.


<strong>Relationship to Web Animation API</strong>: Animations running on <a>Animation
Worklet</a> do not necessarily run on main thread and thus are not synchronized with <a>default
document timeline</a>. At the moment we do not expose any API to start, stop, compose or otherwise
control these animations from outside the worklet however our plan is to leverage existing web 
animation APIs such as Element::getAnimations().

Note: <strong>Access to input</strong>: We are interested on exposing additional user input (e.g.,
scrolling input) to these animations so that authors can create jank-free input driven animations
which are not really possible today.


Animation Worklet {#animation-worklet-desc}
==============================
<dfn>Animation Worklet</dfn> is a {{Worklet}} responsible for all classes related to custom
animations. The worklet can be accessed via {{animationWorklet}} attribute.

The {{animationWorklet}}'s <a>worklet global scope type</a> is {{AnimationWorkletGlobalScope}}.

<pre class='idl'>
partial interface Window {
    [SameObject] readonly attribute Worklet animationWorklet;
};
</pre>

<pre class='idl'>
callback VoidFunction = void ();

[Global=(Worklet,AnimationWorklet),Exposed=AnimationWorklet]
interface AnimationWorkletGlobalScope : WorkletGlobalScope {
    void registerAnimator(DOMString name, VoidFunction animatorCtor);
};
</pre>


<div class='note'>
    Note: This is how the class should look.
    <pre class='lang-javascript'>
        class FooAnimator {
            static get inputProperties() { return ['--foo']; }
            static get outputProperties() { return ['transform']; }

            animate(root, children, timeline) {
                // Animation frame logic goes here
            }
        }
    </pre>
</div>



Concepts {#concepts}
====================
A <dfn>animator definition</dfn> describes an author defined animation which can be referenced by
an <a>animator</a>. It consists of:

 - A <dfn>class constructor</dfn>.

 - A <dfn>animate function</dfn>.
 
 - A <dfn>animator input property list</dfn>.

 - A <dfn>animator output property list</dfn>.

 - A <dfn>animator root input property list</dfn>.

 - A <dfn>animator root output property list</dfn>.


An <dfn>element proxy</dfn> defines a handle to an <a>element</a> which can be used to read or
mutate explicitly exposed <a>animatable attribute</a>s on it. It consists of:

 - A <dfn>proxied element</dfn>

 - A map of proxied input attributes and their values

An <dfn>animator</dfn> describes a fully realized custom animation linking an <a>animator
definition</a> with the instance specific:

 - A <a>animator name</a>.

 - An <a>animator scope</a>.


A <a>animator</a> instance has an associated <a>animator scope</a> which is responsible for 
specific animator state such as its element proxies. It consists of:

 - A </a>animator name</a>.

 - An <a>animation requested flag</a>.

 - A <dfn>rootelement proxy</dfn>.

 - A list of associated <dfn>children element proxies</dfn>.


Issue: Todo: Remove the concept of <a>animator scope</a> and merge what it owns in <a>animator</a>. 
The concept of animator scope is no longer needed because we have decided not to kill animator 
instances mid frame so state can be saved there. Also we are removing the message ports so we 
no longer need to keep them alive independently.


Registering an Animator {#registering-animator}
============================================================
The {{AnimationWorkletGlobalScope}} has a <dfn>animator name to animator definition map</dfn>.
The map gets populated when {{registerAnimator(name, animatorCtor)}} is called.

When the <dfn method for=AnimationWorkletGlobalScope>registerAnimator(|name|,
|animatorCtor|)</dfn> method is called, the user agent <em>must</em> run the following steps:

    1. If the |name| is not a valid <<ident>>, <a>throw</a> a <a>TypeError</a> and abort all these
        steps.

    2. If the |name| exists as a key in the <a>animator name to animator definition map</a>,
        <a>throw</a> a <a>NotSupportedError</a> and abort all these steps.

    3. If the result of <a>IsConstructor</a>(|animatorCtor|) is false, <a>throw</a> a
        <a>TypeError</a> and abort all these steps.

    4. Let |prototype| be the result of <a>Get</a>(|animatorCtor|, "prototype").

    5. If the result of <a>Type</a>(|prototype|) is not Object, <a>throw</a> a <a>TypeError</a>
        and abort all these steps.

    6. Let |animate| be the result of <a>Get</a>(|prototype|, "animate").

    7. If the result of <a>IsCallable</a>(|animate|) is false, <a>throw</a> a <a>TypeError</a> and
        abort all these steps.

    8. Let |inputProperties| be the result of <a>parsing a property list</a> with name
       "inputProperties" for |animatorCtor|. If an exception is thrown, rethrow the exception and
       abort all these steps.

    9. Let |outputProperties| be the result of <a>parsing a property list</a> with name
       "outputProperties" for |animatorCtor|. If an exception is thrown, rethrow the exception and
       abort all these steps.

    10. Let |rootInputProperties| be the result of <a>parsing a property list</a> with name
        "rootInputProperties" for |animatorCtor|. If an exception is thrown, rethrow the exception
        and abort all these steps.

    11. Let |rootOutputProperties| be the result of <a>parsing a property list</a> with name
        "rootOutputProperties" for |animatorCtor|. If an exception is thrown, rethrow the exception
        and abort all these steps.


    12. Let |definition| be a new <a>animator definition</a> with:

        - <a>animator name</a> being |name|

        - <a>class constructor</a> being |animatorCtor|

        - <a>animate function</a> being |animate|

        - <a>animator input property list</a> being |inputProperties|

        - <a>animator input property list</a> being |outputProperties|

        - <a>animator root input property list</a> being |rootInputProperties|

        - <a>animator root output property list</a> being |rootOutputProperties|


    13. Add the key-value pair (|name| - |definition|) to the <a>animator name to animation
        definition map</a> of the associated <a>document</a>.


The {{AnimationWorkletGlobalScope}} has a <dfn>animator name to instance map</dfn>. The map is
populated when the user agent constructs a new <a>animator</a> instance.

When <dfn>parsing a property list</dfn> with name <a>name</a> for <a>animatorCtor</a>, 
the user agent <em>must</em> run the following steps:

    1. Let |properties| be an empty <code>sequence&lt;DOMString></code>

    2. Let |propertiesIterable| be the result of <a>Get</a>(|animatorCtor|, |name|).

    3. If |propertiesIterable| is not undefined, then set |properties| to the result of
        <a>converting</a> |propertiesIterable| to a <code>sequence&lt;DOMString></code>. If an
        exception is thrown, rethrow the exception and abort all these steps.



Creating an Animator {#creating-animator}
====================================================
The {{AnimationWorkletGlobalScope}} has a <dfn>animator scope list</dfn>. An <a>animator scope</a> 
is constructed and added to the list whenever a new <a>animator</a> instance is constructed.

The <a>animator scope</a> contains animator specific message port so unlike animator instances
they cannot be disposed arbitrarily. Additionally, each scope is able to communicate with
its associated animator instance in the <a>browsing context</a> through an implicit <a>message
channel</a>.



<pre class='idl'>
[
    Exposed=(Window),
    RaisesException=Constructor,
    Constructor(DOMString name)
] interface Animator {
    [RaisesException]  void postMessage(any message, optional sequence&lt;Transferable&gt; transfer);
    attribute EventHandler onmessage;
};
</pre>


<pre class='idl'>
[
    Exposed=(AnimationWorklet)
] interface AnimatorScope {
    [RaisesException] void postMessage(any message, optional sequence&lt;Transferable&gt; transfer);
    attribute EventHandler onmessage;
};
</pre>

When the {{Animator}} constructor is called the user agent <em>must</em> run the following
steps:
    1. Let |name| be the first argument of the constructor.

    2. Let |workletGlobalScope| be a {{AnimationWorkletGlobalScope}} from the list of
        <a>worklet's WorkletGlobalScopes</a> from the animation {{Worklet}}.

    3. Let |definition| be the result of looking up |name| on the |workletGlobalScope|'s
        <a>animator name to animator definition map</a>.

        If |definition| does not exist, <a>throw</a> a <a>NotSupportedError</a> and abort
        the following steps.

    4. <a>Create a new {{MessagePort}} object</a>. Let this be the |outside port|.

    5. Let |animator| be a new {{Animator}} Object with:

        - <a>animator name</a> being |name|

        - <a>message port</> being |outside port|

    6. <a>Create a new animator scope</a> with <a>animator name</a> |name|, and
        {{MessagePort}} |outside port|. Let this be the |scope|

    7. Associate |scope| with |animator|.

    8. Return |animator|.

To <dfn>create a new animator scope</dfn> given <a>animator name</a> as |name|, and
{{MessagePort}} as |outside port|, the user agent <em>must</em> run the following steps:
    1. Create a new {{AnimatorScope}} object |scope| with:

        - <a>animator name</a> being |name|

        - <a>animation request flag</a> being <arequested</a>

    2. <a>Create a new {{MessagePort}} object</a> owned by |scope|. Let |inside port| be this
        new object.

    3. <a>Entangle</a> |outside port| and |inside port|.

    4. Set |scope|'s port to |inside port|

    5. Add |scope| to <a>animator scope list</a>.


Creating an Element Proxy {#creating-element-proxy}
====================================================
An <a>element proxy</a> can be constructed in the document scope using the {{ElementProxy}}
constructor. <a>element proxy</a> is a <a>clonable object</a> and thus can be serialized in a
message and posted to any <a>animator scope</a> via the <a>animator</a> port.

The {{ElementProxy}} constructor takes two parameters, first the element which is being proxied,
and second a list of {{DOMString}} identifying all of the <a>worklet animatable attribute</a>
which may be read or mutated using this proxy.


<pre class='idl'>
[
    Exposed=(Window,AnimationWorklet),
    RaisesException=Constructor,
    Constructor(Element element, sequence<DOMString> proxiedAttributes)
] interface ElementProxy {
    attribute StylePropertyMapReadOnly inputStyleMap;
    attribute StylePropertyMapReadOnly outputStyleMap;
};
</pre>

Issue: Need to figure out how we are handlign scroll offsets. Previous approach was to have 
mutable offset on each proxy but the new idea is to have readonly ScrollTimeline.

When the {{ElementProxy}} constructor is called the user agent <em>must</em> run the following
steps:

    1. Let |element| and |proxiedAttributes| be the first and second arguments of the constructor.

    2. If |element| is null or not an instance of {{Element}} abort the following steps.

    4. If any of the attribute in |proxiedAttributes| is not a <a>worklet animatable attribute</a>
        i.e., cannot be read or cannot be mutated inside an <a>animation worklet</a>, <a>throw</a>
        a <a>NotSupportedError</a> and abort the following steps.


    3. Let |proxy| be a new {{ElementProxy}} Object with:

        - <a>proxied element</a> being |element|

    4. <a>update proxy input style map</a> with |proxy| and |proxiedAttributes|.

    5. Return proxy.


Any write on the outputStyle map, updates the effective value of the used style value of the on the
proxied element. This happens asynchronously.


Issue: We now longer allow direct construction of ElementProxy. Remove it.

Issue: Explain what happens when a proxied element is removed.
    In other houdini APIs (e.g., paint and layout) the painter is only invocated if the
    element is alive. In <a>Animation Worklet</a> this is not the case so proxied element may get
    removed while worklet has a handle on them.


When the user agent wants to <dfn>update proxy input style map</dfn> given |proxy|, and
|properties|, it <em>must</em> run the following steps:


    1. Let |styleMap| be a new {{StylePropertyMapReadOnly}} populated with <em>only</em> the
        <a>computed value</a> of <a>proxied element</a> for properties listed in |properties|.

    2. Set |proxy|'s inputStyleMap to |styleMap|.



Running Animators {#running-animators}
======================================================
Each <a>animator</a> is associated with an <dfn>animation requested flag</dfn>. It must be
either <dfn>frame-requested</dfn>, <dfn>frame-not-requested</dfn>. It is initially set to
<a>frame-requested</a>.

When a user agent wants to produce a new animation frame, if for a <a>animator</a> the
associated <a>animation request flag</a> is <a>frame-requested</a> then the the user agent
<em>must</em> <a>run animators</a> for the current frame.

Note: The user agent is not required to run animations on every frame. It is legal to defer
      <a>generating an animation frame<a> until a later frame. This allow the user agent to
      provide a different service level according to their policy. 


When the user agent wants to <dfn>run animators</dfn>, it <em>must</em> iterates over <a>animator
scope list</a> as |scope|:

  1. If the <a>animation requested flag</a> for the scope is <a>frame-not-requested</a>
        the user agent <em>may</em> abort all the following steps.

  2. Let |name| be the <a>animator name</a> of |scope|.

  3. Let |workletGlobalScope| be a {{AnimationWorkletGlobalScope}} from the list of <a>worklet's
        WorkletGlobalScopes</a> from the animation {{Worklet}}.

  4. Let the |definition| be the result of looking up |name| on the |workletGlobalScope|'s
        <a>animator name to animator definition map</a>.

      If |definition| does not exist abort the following steps.

  5. Let |animatorInstance| be the result of looking up |name| on |workletGlobalScope|'s
        <a>animator name to instance map</a>. If |animatorInstance| is null run the following
        substeps:

        Issue: TODO: Add steps to create new animation instance given the animator definition.

  6. Let |animateFunction| be |definition|'s <a>animate function</a>.

  9. Let |timestamp| be a {{DOMHighResTimeStamp}} indicating the current frame start time.

  10. Let |timeline| be a new {{AnimationTimline}} with its "currentTime" set to |timestamp|.

  11. Let |root| be a <a>root element proxy</a> of |scope|.

  12. Let |children| be a <a>children element proxies</a> of |scope|.

  11. <a>Invoke</a> |animateFunction| with arguments «|root|, |children|, |timeline|»,
        and with |animatorInstance| as the <a>callback this value</a>.


Note: It is legal for the user agent to <a>run an animator</a> multiple times in the same
frame.

Issue: We should add provision that allows user agents to skip calling <a>animate</a> 
    on any <a>animators</a> whose proxies are not within the visual viewport or whose attributes
    are not mutated.

Closing an Animator {#closing-animator}
====================================================
TODO: Define a close function that ends the animator. It can be called from document context or
animation context.


CSS Animator Notation {#css-animator-notation}
==============================================

Two CSS properties 'animator' and 'animator-root' may be used to 
assign an HTML elements to an animator instance either as a root element or a child element.


<pre class='propdef'>
Name: animator
Value:  [ none |  <<ident>> ]#
Initial: auto
Applies to: all elements
Inherited: no
Computed value: as specified
Percentages: N/A
Media: interactive
Animatable: no
</pre>

<dl dfn-type=value dfn-for=animator-root>
    <dt><dfn>none</dfn>
    <dd>
        There will be no animators.
    <dt><dfn><<ident>></dfn>
    <dd>
       If there is a <a>animator definition</a> registered with that name, then a new
       <a>animator</a> instance will be created with this element as its <a>root element proxy</a>.
       The new <a>animator</a> lifetime is tied to this root element's lifetime. If no <a>animator
       definition</a> exists with that name, then the instance will be created as soon as one is
       registered.
</dl>



<pre class='propdef'>
Name: animator-root
Value:  [ none |  <<ident>> ]#
Initial: none
Applies to: all elements
Inherited: no
Computed value: as specified
Percentages: N/A
Media: interactive
Animatable: no
</pre>


<dl dfn-type=value dfn-for=animator>
    <dt><dfn>none</dfn>
    <dd>
        There will be no animators.
    <dt><dfn><<ident>></dfn>
    <dd>
      If there is a <a>animator definition</a> registered with that name, then this element is
      assigned to the first ancestor animator instance of the given name as a child element proxy.
      If no <a>animator definition</a> exists with that name, then the element gets assigned as soon
      as one is registered.

      Issue: TODO: If no ancestor animator instance exists with that name then we should create one
      with document root element as its root.
</dl>


Note: All the elements in the root element's DOM sub-tree that get associated with the same animator
 name will get assigned to the the animator instance linked with this root element.


Issue: Todo: Write the algorithm for element assignments. It will include construction of a new
{{ElementProxy}}, looking up or creating animator instance, and assiging the animator. We probably
need a diagram here too.


Effect Stack {#effect-stack}
============================

Issue: Todo: the animators output style values have the highest order in animation stack effect and
their composite operation is "replace" which is going to allow them to run independent on other
animations and in a different thread. Supporting other composite operation is not in scope at this
point.


Receiving and Sending Message {#receiving-and-sending-message}
=============================================================

Each {{Animator}} instances have an implicit {{MessagePort}} associated with them. This port
is created when the animator instance is created and should have a lifetime that is as long as the
animator instance's lifetime.

Similarly, each <a>animator scope</a> has a {{MessagePort}} which is entangled with the
associated <a>animator</a> port. Together, these ports create an implicit <a>message
channel</a> which can be used to communicate between the animator instance and its scope.

All messages received by the <a>animator</a> port <em>should</em> immediately be re-
targeted at the {{Animator}} instance. Similarly any invocation of {{postMessage()}} on the
animator instance <em>must</em> immediately invoke the method of the same name on the port, with
the same arguments, and return the same return value.

All messages received by the <a>animator scope</a> port <em>should</em> immediately be re-
targeted at an <a>animation instance</a>. This requires the worklet to first associate the scope
with an <a>animation instance</a>. Similarly any invocation of {{postMessage()}} on the animation
instance must immediately invoke the method of the same name on the port, with the same arguments,
and return the same return value.


Note: It is legal for a user agents to only deliver messages to an animator scope
immediately before running that animator. Similarly messages to an animator may be deferred
to any appropriate time in the document lifecycle.



Examples {#examples}
====================

Example 1: A fade-in animation with spring timing. {#example-1}
-----------------------------------------

<pre class='lang-markup'>
.myFadein {
  animator:'spring-fadein';
}

&lt;section class='myFadein'&gt;&lt;/sectionlt;
&lt;section class='myFadein' style="--spring-k: 25;"&gt;&lt;/sectionlt;

&lt;scriptlt;
document.animationWorklet.import('spring-timing.js');
&lt;/scriptlt;

</pre>

<pre class='lang-javascript'>
// Inside AnimationWorkletGlobalScope
registerAnimator('spring-fadein', class {

    static inputProperties =  ['--spring-k'];
    static outputProperties =  ['opacity'];
    static inputTime = true;

    animate(root, children, timeline) {
        this.startTime_ = this.startTime_ || timeline.currentTime;
        const deltaT = timeline.currentTime - this.startTime_;
        children.forEach(elem => {
          // read a custom css property.
          const k = elem.inputStyleMap.get('--spring-k') || 1;
          // compute progress using a fancy spring timing function.
          const effectiveValue = 1 * springTiming(deltaT, k);
          // update opacity accordingly.
          elem.ouputStyleMap.opacity = effectiveValue;
        });
    }

    springTiming(deltaT, k) {
        // simulate the spring effect and return a progress value between [-1, 1];
    }
});
</pre>
